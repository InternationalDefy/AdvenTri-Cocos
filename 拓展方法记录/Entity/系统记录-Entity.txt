Entity		作为所有Entity（包括Player Enemy NPC ItemEntity）的基类，继承自M_EffectSprite（可以被添加shaders） 
	主要包括以下几个大的模块：
Entity类 完全实现的模块：
事件模块：	由DispatchParser* 和 CallbackParser* 组成，在设置ListenerSet* 时添加，拥有管理两个模块的函数，但最终都是调用Sys_Event 的接口实现。
实体名称模块：	由 string EntityTag 和 int EntityState 组成，由场景类在创建 实体 时设置，可以被 场景类按名字访问，也用于存档体系沟通。
动作模组模块：	由 M_AnimationPack* 为主体，控制函数保证该实体只播放 一个动作 用 runAnimaiton(const std::string& key) 实现动作播放。
阴影效果模块：	由 M_Shadow*（M_EffectSprite派生类的实例） 为主体，在 实体 设置材质时初始化设定其存在。
实体控制器模块：	由 pCtrl 和 Ctrl_Base 两个类的实例组成，因为其行使机制不同。同时拥有管理控制器的函数

子类实现的函数：
addToScene(Layer* layer,int zOrder) 实体类不使用 直接add， 因为在addToScene的时候需要执行 诸如开启控制器，注册监听函数 等初始化操作，这些由子类实现调用方法。
destory() destory是实体 在游戏逻辑上的 死亡，表示的是 生命值达到 0 以后 执行包括 播放死亡动画，计数器执行操作，发送死亡事件给监听器函数 等。在 内存管理上的 死亡则实现于 removeFromParent()函数 中。
removeFromParent() removeFromParent() 是实体 在内存管理上的 死亡，执行包括控制器，事件监听器等 的移除操作，Entity类 实现了事件监听器和控制器的移除。
子类实现：先执行父类方法，再移除 自身拓展 的实例。

子节点生命周期：参考各自部分的文档记录。

NPC类 拓展的模块：

语言模块：（目前实现的设计）	M_LaEmojiPack只存储 “场景语言”，speak（）方法只创造“场景语言”，实际说话动作的逻辑完全交由UI部分（未实现）
语言模块：（待实现的修改）	M_LaEmojiPack存储 所有语言，speak（）方法涉及很多逻辑包括逻辑上的 场景暂停，场景存储一个当前对话目标 M_NPC*，并注册一个全局事件监听机制，用来响应getLaEmoji消息，用key作为变量，获取该场景的 M_NPC 的 LaEmojiPack 的 key Pack。UI可以通过这个机制，在M_LaEmojiPack中实现对话分支 的 设计。
易伤模块：	在收到伤害之后会被消灭的NPC，有的NPC则是无敌。

Enemy类 拓展的模块：

事实上除技能模块和实体状态模块外的模块很冗杂 甚至没有必要。以后的目标是简化这个系统甚至 重构。

伤害处理模块：	同
负面状态模块：	同
实体状态模块：	同
技能模块：	
武器模块：	Weapon类的实例继承自Sprite，附加在Enemy类实例之上，处理 攻击动画 和 伤害计算，不牵扯技能属性。
护甲模块：	Amor类没有P-H体系或派生类方法，而是通过枚举的形式设置了伤害值的增减，目前有几种简单的类型，由Enum.h 记录并实现。

事实上除技能模块和实体状态模块外的模块很冗杂 甚至没有必要。以后的目标是简化这个系统甚至 重构。

Player类 拓展的模块：
伤害处理模块：	自动机处理，以Enum记录各状态，使用较多的case语句，具体所有方法在PlayerState.cpp 中实现。
具体收到伤害要使用 setOnHurtDamage，setOnHurtType，再Hurt。doHurt操作则不同。
负面状态模块：	自动机处理，以Enum记录各状态，使用较多的case语句，具体所有方法在PlayerState.cpp 中实现。
实体状态模块：	自动机处理，以Enum记录各状态，使用较多的case语句，具体所有方法在PlayerActivity.cpp 中实现。
技能模块：	
这里记录技能类的拓展方法
