现在主菜单的效果并不如人意，问题集中表现在以下几个方面：
1：随机运动的时间应该是一个不同的值，不能使用定值
2：随机运动的物体颜色应该更暗一些
3：铅笔动画仍需调整。
4：单元件素材仍未完成。
接受素材・中仅有翻页动画可用。。。
5：主菜单的翻页动画？

1解决
2解决
3解决 但是铅笔画风还待考虑。

先不考虑45，先进行第一场景的创建和测试体系的搭建。

测试体系需要：
A 完全数据驱动的大关，
B 预加载每一个系统并且监控其加载情况
C 可以用一个特定的存档，打开特定的场景
D 存档编辑能力

*******************
以上为9月24日日志
*******************
24日以及以前的日志记录了主菜单阶段的工作。

现在开始设计一个测试体系，它的基本思路是在尽可能保存确定设计和场景数据的情况下从某个节点开始测试。
思考确定设计和场景数据的具体内容，同时思考在设计改变时场景测试体系如何响应：
确定设计：
数据库设计，已经加载的数据库，已经编程录入的逻辑
场景数据：
需要加载的某个存档，场景其他实体的状态，

1：由于存档系统的实现很简单且没有具体脚本控制，这里也许需要考虑对存档系统的重构。
2：先不考虑复杂的存档系统，利用简单的游戏原型思考测试体系的搭建
例如Aaero：
测试某一关卡的某一段时需要的数据包括：
生命，分数，乘数，开始节点（音乐播放时间和Aero位置）

测试体系需要在数据改动时不和数据解耦。这就需要以下一些必须的方面：
1：确保数据改动没有使数据库出现读取规则漏洞
2：确保改动的数据可以在当前场景中还原
3：确保修改的内容独立在当前关卡中测试
以下设计可能需要修改：
1：关卡数据库不能再使用整体式，应该分开为单文件一个关卡的处理。
2：测试体系前应该有一个对所有使用数据库的预加载活动，并且能够标明出现差错的数据库所在。
3：必须有一个更简单有效的动态修改存档的系统或工具。
以上的方向，现在考虑具体的修改：

1：直接修改数据库DB_GameLayer和Table_GameLayer.csv

2：测试类初始化方法中添加预加载数据库的方法。

3：对存档系统加一个带有图形界面的编辑器？还是使用shell类似的脚本？
推荐使用脚本构建存档编辑器。

添加新类：“M_SaveEditor”

*******************
以上为10月11日日志
*******************
我们需要的测试类不仅是一个可以测试的场景，需要一个测试体系，可以对每一个部分，每一个系统，进行分离式测试。
一个体系可以进行 只考虑实体创建的测试，只考虑存档加载，只考虑素材等的测试，或干脆只使用两个实体在创建。
进行类似的测试时
只需要测试的要素出现在场景中，
并且确保在创建和生成的过程中派出其他系统可能产生bug的干扰
还需要使 需要测试的内容 方便编辑，修改 和 添加。

1：独立
2：排除干扰
3：易于编辑
4：易于修改

4实现于DB系统

当前构想：
一个测试类
Scene_Test
Layer_Test？
测试包括：
生成某场景的方法
完全可以替换的UI体系
在该场景中任意添加种种实体和逻辑的方法

看起来无从下手，
也许参考test cpp中的实现

cpptest的实现方式大部分依赖于按钮，但是按钮只能作为开关使用，并不能使用在广泛，需要拓展的多类多实例测试之中。
TEST_CASE由各派生类自己实现，使用宏添加
需注意，这里cpptest只测试的是有无的问题，并没有考虑到实现的可行性。
所以要考虑的是构建一个TESTCASE，在一个testScene中自定义脚本系统，而testcase则可以支持多种test的共同使用。

Scene_Test类
UI_Layer
Layer_Test* testlayer单例（由testlayer单例实现testlayer的添加）
在创建时初始化数据库等。并选择对应的layer名称，
需要一个开关来控制UILayer和GameLayer的开合。
***由testlayer处理场景逻辑方面的test构建
Layer_Test类
LayerTest类并不直接作为SceneTest的子节点出现，而是用来建立一个TestLayer作为其子节点
在有参数给其传递时，直接创建gamelayer代替之（或将testlayer作为gamelayer的派生类？）

抉择
派生类？管理类？平行类？
派生类不可能了，GameLayer的创建过分依赖于SD
管理类能将管理功能整合在TestLayer中，使用管理类。

*******************
以上为11日日志
*******************
将GameLayer添加friendclass Test_Layer方便其管理，同时修改M_GameLayer.cpp为其添加#include "Ref_TestCase.h"
在考虑Test_Scene能做什么的时候，应该先考量Sys_Scene之前的体系是如何实现Scenen创建的。
毕竟写得久了都TM忘了/。。。。 
getScene操作先将字符串群经过脱脚本，转换为无脚本SD，脱脚本过程可以监控，暂停。然后用无脚本SD创建场景，同时还牵扯SplashScene，
用一个无脚本测试类？创建无主角场景？无SplashScene？类似的方法如何实现？

1：SplashScene的处理：可以创建一个无动作SplashScene？注！场景创建的所有方法在GameLayerBase中，也许可以直接访问其？ 
No！脱脚本在M_GameLayer的创建操作中。这下子混了。
还有可以修改的余地：
脚本化前还是脚本化后，实质都只是添加了一个某属性某名字的Entity来初始化场景而已，

！！！！！！！！！！！如果给Test或GameLayer中加入直接修改测试方案的函数。那就可以来进行测试。！！！！！！！！！！！！！！！
！
！！！！！！！！！！为了方便修改，可以给GameLayer或Test类中加入文本分析函数，用一个可编辑的文本文件（不一定是csv）来实现测试的修改。！！！！！！！
！
！！！！！！！！！！关于脚本正确性的检验！！！！！！！！！！！！！！！！！！！
可以在SysScene中加入脚本正确性检查函数，如果得不出结论就halt？
或者在脚本分析器中加入排错机制？

目前分析其没有排错机制，返回错误值也不是不可能。。。

逻辑上讲，应该在脚本分析器中实现该功能，但是时序上，应该由SysScene完成

严格来说，上面的文本分析和修改测试方案的函数都应该直接在Test类中实现。

在Scene层面又出现了一个问题：我们要测试什么？
Scene层面
1 特定场景构建是否成功
2 SD的读取是否成功
3 数据库构建是否成功
4 在无Scene的情况下考虑UI？
Layer层面
A 空场景状况下测试
1 某数值设计
2 NPC的排布
3 实体类操作
4 敌人战斗难度
B 有存档的状况下进行某关卡测试
1 演出效果
2 游戏节奏
3 游戏进度
B测试可以直接在指定的GameLayer中执行，但也需要一个能够开启和快速修改的机制。

*******************
以上为12日日志
*******************

！应该注意，使自己免于手游！

考虑到UILayer并不是由Scene作为直接父节点的，TestLayer应该具备添加任意UILayer的功能。

这里把基本的函数架构都写好了，下面需要：
1：完善创建方法。
2：添加GameLayer类的编辑函数。
3：考虑：GameLayer如何完善一个Scene，这里牵扯到Scene和UI的设置。
4：在完善测试体系之后，我们还需要记录以下场景类的拓展方法。

3：Scene实际上在GameLayer的getScene方法中创建，并且使用了UI体系的方法来添加UI层，
但 其创建的Scene只是普通的Scene，添加的Layer也是基类而非派生类，且UILayer也使用的是UI系统的标准方法。

对于测试类而言，完全可以使用同样的方法构建UILayer或GameLayer。

Border的实现方法：在SD_GameLayer中的一个数据段，定义了Border。
也许需要额外的文件解析来实现TestBorder或者不需要Border。

添加了一系列set，现在需要考虑init()函数中是否确实的init操作。

并没有/。

*******************
以上为13日日志
*******************
在昨天的基础上完善各类测试函数，完成测试体系，这是今天的任务
上下对比，考虑添加函数的正确处理方案
在Enemy类的管理中看到了EntityTAG，目前是个未知属性，程序中无其他地方使用它。
好在数据库中给出了其定义。

Player只做基础的添加操作，其余属性可以get之后设置。
Border BackGround类似的形式处理，文档在M_GameLyaerBase.cpp和M_GameLayerBase.h中。

BackGround涉及监听函数 和 动画等 过于复杂，是否考虑逐一添加？

测试体系完成，在Test_Layer中的edit方法中修改测试内容，测试时修改Appdelegate中的Name来修改场景。
	顺利实现。
