在两个月慌得一笔的停工之后，
无事可做产生的空洞和虚无是自卑的一大根源，也是未来的一大毒瘤。现在我们得以回归编程，这很幸福，很踏实。
蹬三轮很有趣。
尝试网络传达意思的想法很美好。
终究还是靠面对面才能传达正确意思。
现在开始努力工作！

进行了一些设计考量，需要对当前体系进行修改。

*编程实现实体距离投影，单方向
决定：
1 投影的实现方案：
A 移动：追随实体而移动
B 背景距离：预处理设置，由当前场景类固定距离
C 形状：平行光投影，同样图形，调整黑色变暗，边缘模糊
D 平行光束方向：场景设置光方向
2 投影的编码位置：实体类加入场景时

*细节效果动画，单元素编程实现动画
决定：
实现方案：使用DB-SD体系，和P-H体系的模板拓展
实现位置：使用之前的类进行修改，即ActionHandler体系修改

考虑之前的进度，
5.31的进度：实现了场景类的创建方案和存档系统的结合，但是数据设置需要材质的加入。
先实现单元素编程实现动画。
目前忽视场景类，使用测试类进行继续。
等素材到来之后进行实体距离投影的统一实现。

目前屏蔽了场景类的测试代码，使用测试类继续完善单素材动画。
考量ActionParser类的体系和用法。
ActionParser没有DB-SD体系，无数据库单例，直接使用Vector<>对其进行调用。

P-H体系可以很耐用。
要修改应该从DB_Animation下手。
经过一番考虑之后，Animation和Animate绝对是要分开处理的。
之前所实现的类AnimationPack和DB_Animation应该改名为DB_Animate，其所实现的是对逐帧动画的处理。
DB_Animation体系将作为动作存在，创建一个动作需要对动画进行复制和Get？还是使用动画的Api而调用？
用名称进行复制和get，效率更高，AnimationPack需要存储的是Animation的名字，Animation包括固定的Animate，用名字在DB_Animte里访问，
DB_Aniamte作为单利出现，只存储Animate，
Animatron则是在使用时及预处理载入时生成，生成需要一个对应的Node以及其他参数。

修改思路：
AnimationPack：改名M_AnimationPack，key-FiniteTimeAction*，用DB_AnimationPack-SD_AnimationPack创建，
DB_Animation：改名DB_Animate，文件改名为DB_Animate，为name-Animate*
新类：
SD_AnimationPack：存储的是Pack的信息，
DB_Animation：存储每个Animation，形式为名字-SD对应
SD_Animation：单个Animation的信息，为一个用来表示其参数的SD，SD中可以有Animate的名字在DB_Animate中找寻所需的单动画要素。
具体的SD形式：name,type,numberOfParams,Param1->n
Action单例的P-H体系：
DB_Animation.csv->DB_Animate.csv
在ProcessOn上标注了当前的体系，开始动工修改。

问题1：有一部分调用了Animate（原Animation）的接口
使用接口的是测试类和护甲类和主角类，目前视为调取逐帧动画，在真・Animation类完成之后将其修改回来。
问题2：有一部分程序使用了HitAnimationPack
目前需要删除HitAnimationPack的使用。

添加新类：DB_Animation
SD_Animation
DB_AnimationPack的修改：应该存SD_AnimationPack，M_AnimationPack作为创建时使用的实例，问题是Action可以复制？但Action需要结合Node*和具体参数使用。所以。
改！
改为M_AnimationPack实体创建时创建。SD_AnimationPack仅作为数据存储。

SD_AnimationPack需要的数据：
n(numberOfAnimation) Key-ANimationName Nope!这只需要一个Item就行了？Yeah!

添加了新类SD_AnimationPack 
尚需修改：AnimationPack类的DB体系，M_AnimationPack的多处调用。
有想法删除Amor类。。。可以把它作为数据类？非完整行为的类？
如果需要完整行为，把它归于实体或许可以行得通？
AnimationPack类的各处调用先屏蔽掉。在新的类完成之后，在实体类中统一实现？
旮旯拐角记录：
EPP_PlayerBodyOnEnemy有对HitAnimation调用
Sys_UI对AnimationPack的调用屏蔽
M_Amor
DB_Ebreecd
SD_Ebreed

今天完成了对Animation的初步剥离。明天可以大刀阔斧的修改了。。。

*******************
以上为8月5日日志
*******************
新类Animation的DB-SD体系已经添加完成。

把用SD_Animation获取Node关联的Animation操作实现在M_ActionHandler中。

现在考虑HitAnimation，和AnimationPack在实体类层面的实现。
HitAnimation没有直接关联的Node，而且需要在使用时设置一个位置，如何实现？
使用前，创建一个Node只包含位置信息，作为参数传递给MAH？
这个操作可行，但是需要关联Vec2和父节点作为参数，所以也许由HitAnimation一个特殊的方法处理？
在DB_Animation中处理？但这里不仅是HitAniamtion的问题，所有由环境产生的Animation，均采用如此处理方式。
应该改名为EnvirAnimation，可以由ActionHandler实现吗？可以貌似。。。

对EnvirAnimation进行修改，目前可以实现基础功能。使用方法记录
在场景类中:
M_ActionHandler::getInstance()->runEnvirAction(this,Position,LocalZ,ActionName);
在MAP中定义具体的Name对应的操作:
修改实体类使用Animation的方法。

DebufffNode是一个糟糕的想法，我们应该在实体层面删除它。

AnimationPack现在由ActionHandler生成，由其SD作为数据参照，与对应的实体关联。

在EPP_playerBodyOnEnemy中屏蔽。
在Sys_Ui中createUiItemWithStringData方法中屏蔽有关AnimationPack的操作。

明天需要修改csv文件和添加拓展来实现新Animation的功能测试，并还原屏蔽。