在两个月慌得一笔的停工之后，
无事可做产生的空洞和虚无是自卑的一大根源，也是未来的一大毒瘤。现在我们得以回归编程，这很幸福，很踏实。
蹬三轮很有趣。
尝试网络传达意思的想法很美好。
终究还是靠面对面才能传达正确意思。
现在开始努力工作！

进行了一些设计考量，需要对当前体系进行修改。

*编程实现实体距离投影，单方向
决定：
1 投影的实现方案：
A 移动：追随实体而移动
B 背景距离：预处理设置，由当前场景类固定距离
C 形状：平行光投影，同样图形，调整黑色变暗，边缘模糊
D 平行光束方向：场景设置光方向
2 投影的编码位置：实体类加入场景时

*细节效果动画，单元素编程实现动画
决定：
实现方案：使用DB-SD体系，和P-H体系的模板拓展
实现位置：使用之前的类进行修改，即ActionHandler体系修改

考虑之前的进度，
5.31的进度：实现了场景类的创建方案和存档系统的结合，但是数据设置需要材质的加入。
先实现单元素编程实现动画。
目前忽视场景类，使用测试类进行继续。
等素材到来之后进行实体距离投影的统一实现。

目前屏蔽了场景类的测试代码，使用测试类继续完善单素材动画。
考量ActionParser类的体系和用法。
ActionParser没有DB-SD体系，无数据库单例，直接使用Vector<>对其进行调用。

P-H体系可以很耐用。
要修改应该从DB_Animation下手。
经过一番考虑之后，Animation和Animate绝对是要分开处理的。
之前所实现的类AnimationPack和DB_Animation应该改名为DB_Animate，其所实现的是对逐帧动画的处理。
DB_Animation体系将作为动作存在，创建一个动作需要对动画进行复制和Get？还是使用动画的Api而调用？
用名称进行复制和get，效率更高，AnimationPack需要存储的是Animation的名字，Animation包括固定的Animate，用名字在DB_Animte里访问，
DB_Aniamte作为单利出现，只存储Animate，
Animatron则是在使用时及预处理载入时生成，生成需要一个对应的Node以及其他参数。

修改思路：
AnimationPack：改名M_AnimationPack，key-FiniteTimeAction*，用DB_AnimationPack-SD_AnimationPack创建，
DB_Animation：改名DB_Animate，文件改名为DB_Animate，为name-Animate*
新类：
SD_AnimationPack：存储的是Pack的信息，
DB_Animation：存储每个Animation，形式为名字-SD对应
SD_Animation：单个Animation的信息，为一个用来表示其参数的SD，SD中可以有Animate的名字在DB_Animate中找寻所需的单动画要素。
具体的SD形式：name,type,numberOfParams,Param1->n
Action单例的P-H体系：
DB_Animation.csv->DB_Animate.csv
在ProcessOn上标注了当前的体系，开始动工修改。

问题1：有一部分调用了Animate（原Animation）的接口
使用接口的是测试类和护甲类和主角类，目前视为调取逐帧动画，在真・Animation类完成之后将其修改回来。
问题2：有一部分程序使用了HitAnimationPack
目前需要删除HitAnimationPack的使用。

添加新类：DB_Animation
SD_Animation
DB_AnimationPack的修改：应该存SD_AnimationPack，M_AnimationPack作为创建时使用的实例，问题是Action可以复制？但Action需要结合Node*和具体参数使用。所以。
改！
改为M_AnimationPack实体创建时创建。SD_AnimationPack仅作为数据存储。

SD_AnimationPack需要的数据：
n(numberOfAnimation) Key-ANimationName Nope!这只需要一个Item就行了？Yeah!

添加了新类SD_AnimationPack 
尚需修改：AnimationPack类的DB体系，M_AnimationPack的多处调用。
有想法删除Amor类。。。可以把它作为数据类？非完整行为的类？
如果需要完整行为，把它归于实体或许可以行得通？
AnimationPack类的各处调用先屏蔽掉。在新的类完成之后，在实体类中统一实现？
旮旯拐角记录：
EPP_PlayerBodyOnEnemy有对HitAnimation调用
Sys_UI对AnimationPack的调用屏蔽
M_Amor
DB_Ebreecd
SD_Ebreed

今天完成了对Animation的初步剥离。明天可以大刀阔斧的修改了。。。

*******************
以上为8月5日日志
*******************

今天考虑实体阴影的实现。

*编程实现实体距离投影，单方向
决定：
1 投影的实现方案：
A 移动：追随实体而移动
B 背景距离：预处理设置，由当前场景类固定距离
C 形状：平行光投影，同样图形，调整黑色变暗，边缘模糊
D 平行光束方向：场景设置光方向
2 投影的编码位置：实体类加入场景时

投影需要新类吗？
目前看来不需要，因为没有投影和实体的互动。
投影作为实体类的成员变量以及子节点出现，实体类可以选择是否使用投影的Bool型来设置。
投影类的update函数跟随其父节点（实体）localZOrder为 -1
投影的 背景距离 方向 由场景设定，在实体添加进场景的时候判断是否添加投影，
编码位置是实体加入前，修改场景类的DB，来实现实体阴影的设置。
类的修改

SD_GameLayer 
+ Vec2(LightDirection)
+ 1->n(Entitys Number)
bool enableShadow(n)
float shadowDepth(n)

M_GameLayer
+ Vec2(LightDirection)

M_Entity
+ bool _enableShadow
+ Sprite* _shadowSprite
+ Sprite* getShadow()
+ void setShadow(Vec2 LightDirection,float depth)

*******************
以上为8月9日日志
*******************
实体类的方法进行扩展，再考虑场景类的修改。

现在的问题：
虽然rotation能够跟随实体进行变换，但是相对位置也会随着实体旋转，这不符合光照的效果
也许需要一个Shadow类专门实现阴影效果的旋转，这样，Shadow类还需要考虑到和其他效果的互动。
所以需要谨慎处理。
重新添加M_Shadow类，持有父节点为Entity类

明白了根本原因，是EntityRotation对PositionOff的修正
无法在不修改引擎和大框架的情况下删除该cascade，将shadow作为layer的子节点添加，
在ENtity的remove方法里设置其remove

需要学习shaders来实现基本的模糊效果。
果然是逃不掉的。。。明天学习吧。