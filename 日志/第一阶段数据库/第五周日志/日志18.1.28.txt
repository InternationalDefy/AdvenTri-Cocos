目前暂不修改数据csv文件的名字，需要等完成数据元修改之后

完成对EBreedData类的修改

已完成修改的数据核心：
amor_breed
animation_pack
animation
e_breed
weapon_breed
unit_breed

对PhysicsShapeList的修改已经完成了，但是要去泡妞，所以先跑路了
物理表尚存没有修改的部分
1：对PhysicsShape数据核心的调用操作（主要在Body里）
2：Body类

完成对Body类内和对PhysicsShape数据核心的调用操作，
现在的问题是W_Breed A_Breed等类还有对Body的调用形式没有改变
考虑解决方案，解决方案应当满足的目的
1：对数据核心类有封装性，不用在修改核心类时对数据元进行大部分修改
2：数据元对核心有聚合性，不用在重写数据核心时对数据元大规模修改
3：数据核心之间具有独立性，其相互调用和Include要最简约的形式出现
现有解决方案：
1：根本没有实现 2：较好实现 3：中规中矩
考虑两种解决方案
1：
（1）在命名时保持解耦
（2）用统一格式实现数据元
可能的方案：数据元基类->create set get操作间解耦，用Name实现访问
可以在数据核心聚合结束之后对数据元进行修改，待试，目前使用更加非拙劣的屏蔽法，好于胡乱修改。
2：不改 
3：
Ref类将核心的.h文件引用在一起，就可以实现最小规模的修改
++Ref文件修改容易 --大规模.h可能不易分类Ref
需要一定的经验但是值得尝试，决定使用

*****************
以上为27日日志
*****************
先对wB AB中对body的调用进行拆东墙补西墙式的拙劣修改。

拆东补西并不存在，问题在于.csv数据文件中的耦合很严重，对数据文件中的name和ID进行修改
同时：修改其他数据元的时候要关注Name 和 ID 的转变

完成对Physics数据核心的修改，尚需修改的还有：

controller？
LaEmoji？
~这两个数据元具有比较强的独立性，数据核心对它们进行逐个访问也在编辑时有益
~这两个数据元实际上需要比较强的拓展，对数据核心的修改其实可以建立在逐一访问的基础上
~如果不修改，对数据核心的访问可能会很乱
~这两个数据元具有相对独立性的同时，其余部分的调用比较多
决定修改，并且使用ID和Name的双访问？
如何实现？Vector&&Map
注意存储的是数据所以占用资源量不大，这个解决方案是可行的。

都需要进行修改，LaEmoji数据文件的拓展性很低，Controller的糅合性太强
Controller进行修改先，
Controller使用一个ControllerSD的数据元和ItemSD数据元对不同种类进行统一处理，这种形式需要保留
但是对不同种类的定义会比较糅杂，在ControllerSystem里，对ControllereSystem进行修改，使其以行列形式呈现，

ControllerRef的去留：删去！

先对ControllerBase基类进行修改。

先对StringData进行修改，ControllerStringData和PhysicsStringData要作为派生类出现，
基类使SD_item和包含SD_item的SD_base

ControllerData在item变化时收到了巨大的耦合影响，故需要重写。待

Controller类的改制基本实现，现在的问题是
1、整合性
2、对ControllerSystem继续考量

当前阶段剩余问题：
1：对PhysicsItem进行同样方式的修改
2：把ControllerSystem整合到ControllerDB中
3：仿照ControllerRef的形式建立新的Ref类

先尝试对System的整合
ControllerSystem 目前只能够完成取建的内容，数据元都可以实现，一个System应当是以更加远大的目的而存在的（虽然目前不清楚，但是这个类应当保留）
并且应该将DB类极尽简化，经量地几乎不访问或者判断性访问，这样才有益于上下级解耦。
PhysicsStringData目前不用修改

现在先对Ref进行构建从而实现头文件的易于管理和分类

预采用的分类方法：
1：按程序部分分类
物理 实体 技能 音效 语言 等等
2：按程序结构分类
数据库 数据元 单模型 运行元 运行核心 管理系统

1：
+有相对清晰的结构，在一部分功能进行改动时便于访问
-各元的糅杂关系很严重，跨块修改会对头文件改动较多
S：建立跨块使用的多重Ref头文件集？

2：
+跨块访问更加便宜
-同块访问容易不知所措
S：建立同块相互连接的Ref头文件集？以及需要一个同块之间相互引用的导航性文件

考虑S1 和 S2的难度 复杂性和 耦合性
难度相当 均很小
复杂性 S1>S2 因为要考虑多重文件
耦合性 S1<S2 

选用S1方案
对多重文件经行设计
ProcessOn

关于Ref的设计构想
将Ref文件放在一个筛选器中， 每种文件的部分块使用自己的Ref
均放在Ref筛选器中
Ref_*Part* 某Part所输出的Ref
Ref2*Part* 某Part所使用的Ref