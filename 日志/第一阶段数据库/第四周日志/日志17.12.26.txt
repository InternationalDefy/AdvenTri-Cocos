从底层写起，突然发现dynamic_cast似乎没有必要

不过可选的实现方法是在BreedList中加入表示controller类型的string或者id

内存管理的问题：
1.物理实体并没有被移除->考察物理与实体的关系寻找解决方案
2.二次操作会崩溃->极力避免二次操作？使remove操作在非parent操作中也是内存安全的？
避免而此操作：脏标记模式，下一轮更新时在vector中erase，

注意：Controller和Physics应当是持有数据而非持有实例：如果返回指针会出现共用指针的崩溃情况

解决方案有2：
1.实现clone方法
2.实现数据持有而非实例持有

以方法2实现Controller和Physics，方法1用于LaEmoji

着手开始Animation，使用和PhysicsBody类似的方法

animation可能对多个实例调用，也可能被单个实例多次调用，故每次使用时都要创建一个新的?或者使用animation原代的clone()方法
使用原带的clone()方法，在Data中保存animation的实例列表，
考虑到巨大的内存占用量，在animationData中不应存储实例，应该存储名字数据，在掉用时使用get方法返回实例。
这个方法不一定高效，但是可以选择plist或者在场景创建时预载animation

Animation类已经实现且实现比较完善，可以当作之后的借鉴类使用 
*****************
以上为25日日志
*****************
现在开始构想Breed类，breed类应当拥有一个数据库，并且由于持有数据量巨大，数据库应当只持有数据，在使用时（Enitity创建时）创建实例
楼上先别着急
考虑到breed类只存放各种数据，而方法被Entity持有，其它系统的具体操作直接作用于Entity实例，breed类如果包含了其他系统的实例，则Clone方法就会比较混乱
考虑：以决定数据的持有元
实体存储形式是实例还是数据？
1.实例
++快，+易于取用，-内存占用量可控，-需要不亚于取用操作的clone方法
2.数据
--慢，取用繁复，+内存占用小，+不需要clone方法
3.半实例
将文件操作等耗时但不占太多空间的操作在场景（游戏）运行时创建，
++速度和内存中有不错的平衡，-clone方法将会容易混乱
控制器何时使用？
1.场景初始化时创建实体，需要实体入场时激活（创建）控制器
++运行更快~内存占用量可以接受（控制器并没有巨大的内存量）-场景编程会容易混乱：解决方案则是以足量的标记保障可维护性
2.场景运行中创建实体，在实体入场时经由EntityData创建
--慢，+内存占用小，+可控的场景编程，
物理实体何时使用？
动画何时使用？
技能何时使用？

Breed类十分有限Entity却很多，最佳的形式时实现Entity持有Breed类实例的引用，Breed类持有充足的数据足够Entity在创建时调用并成为完整的Entity
Breed类持有数据，在创建时调用数据构造的方法，在Entity创建时调用该方法使Entity成型。

Breed类数据构建需要更多考量，用两个小时观察ATW的数据系统构建，重新考虑。