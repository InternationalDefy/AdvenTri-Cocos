考察了ATW的数据架构，可以得出以下一些结论
对ATW的考察得出了全战的兵种数据库架构：
Boot.所有兵种信息的存储方式均为数据，预加载时完成所有操作（其中包括数据实例化），这解释了全战很高的CPU占用率，运行效率和极长的读取时间。
Boot.各个数据元之间的访问借由table和key实现，也有对Ref解析的数据元和unique_index存在。
1.兵种类的数据由几大组件（类？）数据和本身持有部分数据构成
组件类：战略地图UI，战略地图声音，战略地图模型数据，战术地图使用数据元（land_table navel_table）
本身数据：征募费，维护费，队伍人数。
未包含：征募条件，征募建筑等等应该包含在建筑之类的存在中。
2.land_unit数据元表示战术场景中某单位兵种的存现形式。
组件类：护甲（作用包含决定了其护甲值，和不同护甲的攻防动作判定），部队种类（步，骑，远，决定了其动作分组和作战属性判定），
动作模组（包含坐骑模组和步战模组），坐骑种类（计算其战斗能力且获取其属性），物理实体（包括坐骑和人物），
使用武器（只和战斗能力有关，因为动作模组已经被细分计算在动作模组里），盾牌种类（与战场属性和兵种显示均有关系），
旗官种类（决定战场旗帜的显示和旗官的形象），分组别（与配置兵种及战略显示有关），选取响应事件（与ui和选取效果有关）
本身数据：弹药量，行军点数，冲锋加成，攻防能力，步战能力（步兵没有步战形态，此处是000占位符），升级能力，弱点，自动分计算规则，藏匿能力，生命值，装填能力，
其设计遵循的原则：
1.宁废毋少，牺牲性能换取的拓展性。
2.绝大多数数据以key和table定义，牺牲性能换取的编辑性。
3.在确定数据库的分部和分组之前，务必先确认数据何时调用，何处调用，何者调用，为何调用，结果如何。

以对totalwar数据库架构的考察，建立起AdvenTri的数据架构
Boot.
实体类拥有为数不多的几个派生类表示大的分类
分别是：主角类，敌人类，可互动类
可互动类：包括场景里一些NPC，景物，摆置，谜题相关等等，有事件回调器存在，但无须敌人类的种种属性。
数据核心均在初始化时创建。
数据核心驱动的实体类实例在场景初始化或敌人出现时创建，视场景类实现而定。
数据核心保存一张引用名列表。
1.
敌人数据类（注意时数据类，不是敌人类实例）
：包含E_Breed类的名称（或标识）用于引用，E_Breed类数据中包含各种对敌人类数据的定义和方法的引用
E_Breed类由组件类信息和本身属性构成
注意是组件类信息而非组件类本身或是组件类引用！
组件类：
0 护甲类型（决定了其属性和战斗时对不同情况的互动，例如金属怕电，木制怕火等），
0 部队类型（决定了其使用的是否使用特定组件和属性），
0 技能类型（与部队类型有关，在部队类型中可以定义），
0 动作模组（不同状态的种种动画，以固定某Animation名字形式存储），
1 物理实体（包含质量，速度限制等属性），
0 武器种类（发射和攻击等操作的实现在武器类中，可以用于解耦），
0（待手动）事件监听类型（对种种事件的响应工作），
0（待手动）使用UI模组（与特定效果表示和语言动作有关），
1 使用控制方案（即Controller类的名字或id，用于在创建敌人时添加Controller）
本身属性：攻击力，攻击速度，防御力，行进速度，生命值，装填能力（如果是远程）
2.
可互动类数据类
：包含N_Breed类的名称或标识，N_Breed类数据中包含各种对NPC数据的定义和方法的引用
N_Breed类由组件类信息和本身属性构成
组件类：
动作模组（不同状态的种种动画，以固定某Animation名字形式存储），
物理实体（包含质量，速度限制等属性），
事件监听类型
（这是NPC类的重点，对不同形式事件的各种响应决定了其存在的目的和形式，此处可能难以用字节码实现，要用到大量分批编程），
使用UI模组（与特定效果表示和语言动作有关），
使用控制方案（即Controller类的名字或id，用于在创建NPC时添加Controller）
本身属性：？不确定是否真的需要？
注意以上在数据类创建时所持有的均是其他类型组件的名称而非实例。
3.
主角类
：非数据类，直接由一个数据元中数据在游戏场景开始时创建
组件类
：所使用均为实例，由数据元以及存档系统设置（参数）并直接创建。
：与存档系统关联并会在UI界面由游戏内部逻辑修改
0 护甲类型（决定了其属性和战斗时对不同情况的互动，例如金属怕电，木制怕火等），
0 动作模组（不同状态的种种动画，以固定某Animation名字形式存储），
1 物理实体（包含质量，速度限制等属性），
0 武器种类（发射和攻击等操作的实现在武器类中，可以用于解耦），
0 （可能需要手动）事件监听类型（对种种事件的响应工作），
0 （可能需要手动）使用UI模组（与特定效果表示和语言动作有关），
1 使用控制方案（Player'sController）
//本身属性：攻击力，攻击速度，防御力，行进速度，生命值，装填能力（如果是远程），经验，升级所需，技能点等等
本身属性和由组件定义属性和存档存取属性共同作用而成，某些组件可以手动编程实现。
对Reference的一种考量
：如果存留reference而非直接寻找方法
+运行效率较高对int的寻址远快于转化或table->string的速度
-需要Reference表认真地设计，很容易出现寻找不到的bug
然而经过思考，Reference是可控的无寻址bug，可以用if!null实现
string如果写错则其bug不可检于程序，因而不可控。