开始设计Enemy类之前，先考虑哪些属性和方法由Enemy持有，哪些由Entity持有
0 护甲类型（决定了其属性和战斗时对不同情况的互动，例如金属怕电，木制怕火等），
0 部队类型（决定了其使用的是否使用特定组件和属性），
0 技能类型（与部队类型有关，在部队类型中可以定义），
0 动作模组（不同状态的种种动画，以固定某Animation名字形式存储），
1 物理实体（包含质量，速度限制等属性），
0 武器种类（发射和攻击等操作的实现在武器类中，可以用于解耦），
0（待手动）事件监听类型（对种种事件的响应工作），
0（待手动）使用UI模组（与特定效果表示和语言动作有关），
1 使用控制方案（即Controller类的名字或id，用于在创建敌人时添加Controller），

问题1：必要性
控制器，事件监听，动作模组，物理实体，UI模组是所有Entity都需要的
部队，技能，护甲，武器等NPC类不需要
问题2：耦合性
对于E和P
控制器可能访问物理实体和部队，技能，
技能访问部队，武器，护甲，
/事件监听可能访问物理实体，动作模组，UI模组
/动作模组只执行，不外访问，
/物理实体只执行，不外访问，
UI模组访问几乎所有持有类（含武器等），
对于N
控制器可能访问物理实体
/事件监听可能访问物理实体，动作模组，UI模组
/动作模组只执行，不外访问，
/物理实体只执行，不外访问，
UI模组几乎访问所有持有类（不含武器等），

物理，动作，事件，在Entity基类中实现，其组件类均可访问Entity，
部队技能，武器护甲，控制器，UI模组，在派生类Fighter类和NPC类中实现，其组件类访问Fighter类和NPC类，
控制器需要用F_Controller和N_Controller分类（继承自Controller？）
Enemy类和Player类继承自Fighter类
楼上的方法可行但是并不优雅，
松耦合继承方法是可以的，组件类中的定义只要保证不访问到没有的属性就可以。