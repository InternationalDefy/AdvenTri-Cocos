今天的目标是以27 28 两日设计考量为蓝本，实现场景类的分级构建。首先完成GameLayer基类和SplashScene，完成的过程考虑两者和UI的关系。
以及友元设置的前提下，如何构建之。
场景的层级创建任务肯定要归于Sys_Scene完成，考虑以下问题：
不同的场景尤指特化场景需要特化的创建方式，不适应Sys_Scene的分派
现在开始完成GameLayer的统一生成方案。

突然发现一个问题：AI系统没有实现，控制器该添加一个新的脚本？来实现AI系统？这个希望可以在快速完成现在的模块后添加。

第一步是添加了场景边界的设置，但是Sys和场景系统并不是很完善，不能够通过显示场景的方法来看效果。
因为之后场景初始化都将是照猫画虎，现在的目标是尝试使用场景系统生成。

纠结于场景的生成和退出的自定义操作，考虑是不是需要在退出时执行特殊操作的支持。
同时考虑生成操作应该传入何种参数，这对Sys_Scene的要求不仅是应该可以实现进出功能，实现脚本调用，更需要实现在正确的地方使用生成方法，免于过分占用游戏时间。
在DB中加入定义，进出操作的模块。用DB_GameLayer
否，取消对GameLayer的EnterActionQuitAction的操作，其出入使用一般的动作实现。而其需要的一些特殊动画，使用EventListener在调用退场或入场方法时发动。

似乎类型不兼容？原来是没有实现SplashScene，现在可以先实现相对简单的SplashScene

实现过程中新决定的设计：
1 SplashScene改为SplashLayer 它是一个Layer子类，拥有创建只包含自身一个Layer的Scene的方法
2 SplashLayer GameLayer均有创建 Scene的方法，GameLayer在创建时添加UI层作为节点
3 SplashLayer GameLayer的init操作均有 Layer类自身完成，这是为了将逻辑整合在一起，Sys_Scene拥有调用两者的方法。
4 GameLayer在创建时需要创建UI层，但是。。。UI层的考虑->需要固定的设置？需要预设函数？需要脚本化？如何保证复用？如何提升创建效率?
5 脚本解析器类M_ScriptParser作为Sys_Scene的子节点被访问？否，可以直接访问。

初步实现了创建操作，但是很多部分需要存档系统库或者UI层相互结合。明天开始筹划存档系统。
*****************
以上为29日日志
*****************
今天要先实现一个存档系统，然后利用存档系统和其他系统结合完成场景类。（听起来有点遥不可及，但目标应该高远）
存档系统的实现方案？XML？CSV?
考察虽然一两行简单的代码就可以实现一个数据的存储和读取，但是一个完整的存档系统应该具备的是批量存储修改的能力，同时还要有很简单的分批能力。
考虑其他动作游戏在存档点时的存档操作，需要存储的信息包括：
主角信息：等级，经验，技能点，所装备的技能，物品栏信息
场景信息：当前所在的场景，场景物品的破坏情况，谜题解析情况，
实体信息：敌人的消灭情况，哪些敌人可以刷新，NPC互动状况，NPC消灭状况
额外信息：某种特殊点数是否触发，某种彩蛋是否遇见
游戏信息：游戏难度，游戏进度，游戏时间
存档系统需要一个能够执行批量分配存档信息的方案。
？同时也需要批量读取操作提供支持？
存档系统的实现目标： 
1 依据已有的存档单元设计
2 可自定义的批量存储
3 可自定义的批量读取
4 特殊数据的精确存储读取
5 多个存档栏位
6 存档清空操作
7 何时存档何种内容的外部调用接口

设计思路：
存档数据分为三个模块，两个大部分，
分别是：场景信息大部，非场景信息大部
场景信息模块，持有类信息模块，隐藏信息模块

何时存读？
存：打开自动保存则 每次切换场景存档。
手动操作点击存档。
读：加载游戏，切换场景时。

存档操作做什么：
当前场景的信息存储
非场景信息大部存储

以下以场景进入退出为例，语言化描述存档系统的想法

场景信息模块的存储和读取仅与场景类相关联，在其进入和退出或达到存盘点时进行读取存储操作。
场景需要存储实体状态，则需要一个std::map<std::string,int> 来表示
同时场景类在创建时给每个实体赋予一个Tag(std::string)在实体有自身情况发生时发送一个信息给场景类，由场景类负责修改其Tag
存读档操作用Tag的存读实现，同样的，场景在创建的时候需要初始化Tag以保证存档的延续性
同时各场景自身也需要一个Tag来进行场景间的区分。 有些存档信息需要传递场景之间，
场景信息存档的外部接口形式时 getSceneSave(SceneTag,EntityTag)(return int Stance)

非场景信息比如主角类信息，物品栏信息等，由自身类持有，并在场景进入时将其存档信息读取，并初始化为自身数据。
在场景退出时，将自身数据存取在存档系统中，以保持维序性。

已有设计的修改
DB_Scene
+string SceneTag
DB_GameLayer&SD_GameLayer:
+string SceneTag
+string(n1+n2) EntityTag
M_GameLayer
+map<string,int> EntityStance
+string SceneTag
M_Entity
+string Tag
M_Player
+M_Player* createWithSave();
+void saveFiles();

这里注意：已选对话选型的存储和读取？
对于NPC类，而言，其状态可以用？xy表示其对话选项为x&y?
Sys_Save
{
int Stance getSceneSave(string SceneTag,string EntityTag)
}
以此设计，尝试构建存档系统。

写了必要函数的声明们，晚上回来写定义。

考虑到有可能主角类等的数据存取需要对一个类进行操作，而这操作
1 需要对其他类的.h文件引用
2 可能会相当复杂
所以也许目前定义和声明的操作是文件中Sys_Save_Basic
而以后可能会添加Sys_Save_Player等

完成了存档系统的基础操作，以下操作尚未实现
1：存档系统与场景系统的联动
2：存档系统与主角类联动
3：特殊存档信息的清空
4：存档覆盖问题和需要添加的TalkBox
基于目前的考虑，可以先实现1

*****************
以上为30日日志
*****************
永恒之柱玩的有点过火了。。。今天还是加紧搞一搞存档。
注意还要实现这些。
已有设计的修改
M_GameLayer
+map<string,int> EntityStance
+string SceneTag
DB_Scene
+string SceneTag
DB_GameLayer&SD_GameLayer:
+string SceneTag
+string(n1+n2) EntityTag
M_Entity
+string Tag

M_Player
+M_Player* createWithSave();
+void saveFiles();

EntityState,EntityTag的设计应当考虑。 这里需要留做一个重点问题。

Scene部分存档系统修改完成。考虑Player部分的修改，之后是利用存档创建场景的操作。
你秀逗了！？Player部分要考虑到很多设计啊，现在还不好实现。不过实现了实体场景存档三结合就好。
可以尝试场景创建初步了。

这里需要先考虑EntityState的具体含义。
？3位
A1A2A3
A3 0存活 1死亡
A2 A1 高位用于表示其他的状态和不同的含义。

初步完成了创建，不过数据设置尚未实现，实装材质时可以考虑，测试目前比较难。
先行测试，缺失素材暂无视。
测试无误，明天拍素材。