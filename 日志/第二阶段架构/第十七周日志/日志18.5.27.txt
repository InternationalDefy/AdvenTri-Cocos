划水到此为止，今天要开始着重于昨天思考之目标而实现设计。
1 背景设计：
背景必然分为两类，有实体的和无实体的，无实体称background，仅仅以Sprite形式出现，可以使用场景类直接定义
有实体的是NPC类，包括破坏，事件分发，对话进入等功能在其中实现，以M_NPC形式出现，使用场景类定义其name来创建
2 地形设计：
（？）地形实际上是Sprite材质+逻辑函数监听的集合，可以通过以下逻辑方法实现？Terran类？通过脚本形式添加范围监听？
一个场景需要设计一个边界值，这个边界会阻拦实体的通过，可以以PhysicsBorder的形式实现
3 事件机制：
利用已有的事件机制实现派发事件，使用ListenerSet进行事件派发的设计，对于每个Entity设计不同的CallbackParser
每一个场景持有自己独有的ListenerSet
在内存管理机制上，重写GetLayer函数，return自己。
4 单位设置：
一部分实体可以直接以开始时设置的形式，在场景初始化时进行设置，在需要其运行的时候打开其控制器。
一部分体需要依靠脚本创建，故不在开始时加载素材，靠事件触发将其出现，并播放入场动作即Enter方法。
5 类似机关和动态：
依靠NPC类实现，但是为了区分机关类NPC和对话类NPC应该在SD中把他们分开定义。
6 运镜及UI
场景类必要持有cCtrl实例，运镜操作时逻辑暂停（由场景类实现）
UI类也需要调用场景的逻辑暂停。
7 SD定义
目前尚不清楚具体的SD设置方法，但是
可以毕竟肯定的是需要使用一个引用表，而其余文件则都是单文件表示一个SD因为场景类内容太多。
8 存档系统关联
存档系统和场景的创建初始化相关，例如存档得到善恶值来判断创建风格，可能会因为一个数值的不同创建截然不同的场景
而且需要使用的存档系统值将不只是善恶值，可能在之前遇见的一些事会触发不同的场景设计，
此处仅指场景设计上的不同，当然也有可能出现这种情况：同一NPC说的语言不同，而非不同的NPC，这个问题可以给NPC类以及其DialoguePack处理
但是最好的处理方案是将 与存档系统沟通的内容 集成在 一个系统 中实现，那场景类就是最佳选项了。
在SD？DB中需要一个脚本解析系统（该来的终究还是逃不掉了）
9 进出以及切换方法
需要提供其余场景类可以调用的外部接口，SplashScene的处理方案等 故一定需要一个enter quit函数作为外部接口
而且本场景可能使用 不同的退场方式， 退至不同的场景，这些可以作为enter quit函数的参数调用
10 特异化场景的实现
需要一个场景管理器类，其管理场景的生成和切换，以及通过SD设置不同的UI之类的操作 
如果出现了标志为特异场景的场景，就调用特异场景的创建方案。
为了方便的使用各种外部接口，大致可以设计继承结构如下
特异场景 : public 场景基类
模式化场景 : public 场景基类
场景基类 : public Layer
场景管理器 : public Ref
管理器中有如下方法
public:
nextScene(编号？名字？)
中间有SplashScene的调用
private:
Scene* createSceneWithSpecailLayer(参数们)
{
SpecailLayerX::create();
可以设置一个SpecailLayerMap?
}
Scene* createSceneWithUsualLayer(参数们)
{
Scene* createWith模式化方法
}
这就决定了DB一定是一个引用表，而每个场景独占单SD才是其核心部分。
但也有可能特异化场景也需要SD设置参数，不过问题是。。。使用的是何种SD？以及SD的设置方案？
通过以上的设计考虑，在ProcessOn上设计SceneManager为核心的数据层级结构

完成了层级结构的设计，主要方法应该标注一些，但那是睡起来以后的事了。。。
主要类方法
-Sys_Save

-Sys_Scene
private:
DB_Scene* _db;
DB_SplashScene* _dbs;
M_SceneScriptParser* _parser;
Sys_Save* _save;
Sys_UI* _ui;
DB_Scene*&SD_Scene包含的是有脚本在其中的SD，经过解析之后变成另一个类返回，即 NSSD_Scene*无脚本SD
DB_SplashScene*同理
private:
Scene* createSceneWithSD(NSSD_Scene*) 
{Scene* sc=Scene::create();NSSD->getType()? gamelayer=createSpecialLayer(NSSD)?gamelayer=createLayerWithSD(NSSD);
uilayer=getUILayer(NSSD_Scene*);addChidl(gamelayer);addChild(uilayer);}
M_GameLayerCommon* createLayerWithSD(NSSD)
{return GamerLayerCommon::create(SD);}
M_GameLayerSpecial* createSpecialLayer(NSSD)
{return XXXSpecialLayer::craete(SD);}
UI_Layer* getUILayer(NSSD_Scene*)
{return UI_Layer::reate(SD);}
Sys_Scene* create();
bool init();
public:
Sys_Scene* getInstance();
void nextScene(const std::string& name)
{SplashScene::createWithNextLayer(name);}
当SplashScene进入后，在OnEnter方法中调用getScene()
Scene* getScene(const std::string& name);
{getSD;_parser->parse(SD);createSceneWithSD;}

-M_GameLayerBase
public Layer
private:
bool _isPaused;
cCtrl* cameraCtrl;
Node*(WithPhysics) Border;
Node*(WithPhysics) cameraBorder;
UI_Layer* ui;
ListenerSet*(以Parsers和Dispatcher作为子节点形式出现)
LaEmojiPack*(即以浮动字形式出现的LaEmoji的预载，其运行可以被设为到何时自动移除，通常只有一页)
public:
update(float){_children->update(dt);}
Scene* createScene(NSSD);
bool init(NSSD);
void pauseUpdate(bool);
void pausePhysics(bool);
void pauseLayer(bool);

*****************
以上为24日日志
*****************
今天的目标是实现场景类。
首先考虑场景的生成和一个与脚本结合的数据库。之前决定需要分开脚本数和非脚本，这次的想法是尽量将他们融合。
使用？形式定义？则需要一个脚本SD，和脱脚本SD。
-UnScriptedSD内存管理问题。
-类型名称管理存在一定程度的混乱。
+可以把脚本化操作和非脚本流水线操作隔离开来。
如果不使用脱脚本SD和原带SD分割的处理方案，那么需要一个SD即能同时涵盖脚本和非脚本，又不使他们分割处理。一个简单的方法是，把脚本设置为必然。
由此处理，毕竟经过考虑，绝大多数场景都是需要脚本的控制的。
只需体验三分钟，你就会变成一个艾斯比。
错了错了。。。只需加入一句INT,1,RET_BOOL.即可设置为必然脚本。
这里考虑：如何区分脚本和数据元。
,是基础，.作为脚本的结束？但这不符合DB原带的分割机制。其实可以设置双行，在已经决定脚本和数据元对应的情况下。

考察之前的日志，合理的设计应该是把SD_Scene分为多个部分，分别是SD_GameLayer SD_SplashScene
其中，SD_UILayer应当实现对UI套组的设置，意在不同场景使用不同的类型UI，或者同一场景的不同条件使用不同的UI，
这里的UI是指UI系列，即一些基础UI如 暂停界面，物品栏等。而如 对话 界面，由不同款式的实体自行定义 技能界面，由主角类和存档系统控制。

重新考虑之后，SD_Scene应该由Sys_UI调用并生成，不应该在GameScene的SD中定义。
1：便于UI层的协变
2：在场景切换的时候，由UI系统读取一些存档中数据来创建UILayer，这些操作不需要脚本来完成。
3：或者在场景内部逻辑更新的时候，Sys或者UILayer通过监听，创建为其他的UILayer？Item？并使用。
这个方案可以很好的将UI逻辑集中到UI的类里来。并且不需要在SD的定义中额外添加工作量和复杂度。

三种SD都需要脚本？还是某些不需要？

SD_Splash SD_UILayer不需要脚本。
SD_GameLayer 和 SD_Scene需要脚本。
考虑SD的呈现形式。
这里考虑脚本分化的具体分布
在SD_Scene中将 SplashScene和UILayer和GameLayer的宏观部分 的脚本分化实现
在GameLayer中实现一些小的分化

SD_SplashScene
主要是实现SplashScene屏幕的数据定义
int NumberOfSprite(n)
1->n string SpriteImage,Vec3 SpritePosition,int SpriteLocalZOrder,
bool EnableAction,string ActionType,Int NumberOfParam(m),1->m params,
bool EnableListenerSet,String ListenerSetName,

SD_UILayer
实现对一个UI套组的材质定义。主要是图片和位置设置的不同。
注意：在游戏进行过程中UI也可能会替换套组，由SD实现，或者由UI系统直接实现。
int NumberOfUIMenu(n)
1->n string MenuName,Vec2 Position,int LocalZOrder,

SD_GameLayer
int NumberOfBackGround(n)
1->n 
int NumberOfScripts(m),Scripts 1->m
string BackGroundImage,Vec3 BackgroundPosition,int BackgroundLocalZOrder,
bool EnableAction,string ActionType,Int NumberOfParam(m), 1->m param,
bool EnableListenerSet,String ListenerSetName,

int NumberOfNpc(n)
1->n
int NumberOfScripts(m),scriptes 1->m
string NpcName,Vec3 NPCPosition,int localZOrder,

//控制Enemy的进入操作在ListenerSet中实现。
int NumberOfListenerSet(n)
1->n
ListenerSetName

int NumberOfEnemy(n)
1->n
int NumberOfScripts(m),Scripts 1->m
string EnemyName,Vec3 EnemyPosition,int LocalZOrder,

SD_Scene
SDScene的属性是：只要由一个1/n满足条件，就直接结束当前语句块。
即找到第一个符合条件的SDGameLayer或者SDUILayer就直接返回其SD。
int NumberOfGameLayer(n)
1->n
int NumberOfScripts(m),Scripts 1->m
string GameLayerName,
?string SD_UIlayerName不确定是否需要此项，因为可以直接在Sys_UI中实现。
int NumberOfSplashScene(n)
1->n
int NumberOfScripts(m),scripts 1->m
string SplashSceneSDName

开始编写带脚本的数据库元。
加入新类？否。使用结构体

成功实现DB_SplashScene,类似于一个不和Scripts结合的DB_GameLayer,下一步实现DB 先玩了。
考虑到DB比较重复的编程模式，虽然对细节的把控比较容易，但是对数据库的拓展相对麻烦，
又考虑到脚本解析器的实现，是否需要使用脚本代为行使对DB的解析系统？
下次（做游戏）试试。

*****************
以上为24日日志
*****************
怠工永远都不是意见好事，今天要好好努力。消除无聊的妄想吧，现实才是应当面对和可以改善的。

考虑到SD_Scene和SD_GameLayer的实现形式与SplashScene相当，但是要加入脚本。先从SD_Scene实现起。

这里注意一个问题，因为DB在访问csv文件时很容易越界且没有合适的排错机制，这是设计上的一个疏漏。。。一开始就有问题。
所以避免这种疏漏代来灾难性后果的一种得当方法是逐个排查DB，也就是每次拓展，需要修改大规模多个DB时，从底层细枝末节出开始DB
逐一修改并尝试。
同时对于n、 m的设置要格外留心。

完成了DB_Scene，现在用类似的方法实现DB_GameLayer.
决定！UI的更新由UI系统实现，内部逻辑函数 调用Sys_UI生成新的套组。
成功实现新的带脚本数据库

数据库完成之后思考GameScene和UIScene的关联以及如何正确地使用Sys结合数据库系统生成。

这里需要参照上月24日日志。

1 背景设计：
背景必然分为两类，有实体的和无实体的，无实体称background，仅仅以Sprite形式出现，可以使用场景类直接定义
有实体的是NPC类，包括破坏，事件分发，对话进入等功能在其中实现，以M_NPC形式出现，使用场景类定义其name来创建
2 地形设计：
（？）地形实际上是Sprite材质+逻辑函数监听的集合，可以通过以下逻辑方法实现？Terran类？通过脚本形式添加范围监听？
一个场景需要设计一个边界值，这个边界会阻拦实体的通过，可以以PhysicsBorder的形式实现
3 事件机制：
利用已有的事件机制实现派发事件，使用ListenerSet进行事件派发的设计，对于每个Entity设计不同的CallbackParser
每一个场景持有自己独有的ListenerSet
在内存管理机制上，重写GetLayer函数，return自己。
4 单位设置：
一部分实体可以直接以开始时设置的形式，在场景初始化时进行设置，在需要其运行的时候打开其控制器。
一部分体需要依靠脚本创建，故不在开始时加载素材，靠事件触发将其出现，并播放入场动作即Enter方法。
5 类似机关和动态：
依靠NPC类实现，但是为了区分机关类NPC和对话类NPC应该在SD中把他们分开定义。
6 运镜及UI
场景类必要持有cCtrl实例，运镜操作时逻辑暂停（由场景类实现）
UI类也需要调用场景的逻辑暂停。
7 SD定义
目前尚不清楚具体的SD设置方法，但是
可以毕竟肯定的是需要使用一个引用表，而其余文件则都是单文件表示一个SD因为场景类内容太多。
8 存档系统关联
存档系统和场景的创建初始化相关，例如存档得到善恶值来判断创建风格，可能会因为一个数值的不同创建截然不同的场景
而且需要使用的存档系统值将不只是善恶值，可能在之前遇见的一些事会触发不同的场景设计，
此处仅指场景设计上的不同，当然也有可能出现这种情况：同一NPC说的语言不同，而非不同的NPC，这个问题可以给NPC类以及其DialoguePack处理
但是最好的处理方案是将 与存档系统沟通的内容 集成在 一个系统 中实现，那场景类就是最佳选项了。
在SD？DB中需要一个脚本解析系统（该来的终究还是逃不掉了）
9 进出以及切换方法
需要提供其余场景类可以调用的外部接口，SplashScene的处理方案等 故一定需要一个enter quit函数作为外部接口
而且本场景可能使用 不同的退场方式， 退至不同的场景，这些可以作为enter quit函数的参数调用
10 特异化场景的实现
需要一个场景管理器类，其管理场景的生成和切换，以及通过SD设置不同的UI之类的操作 
如果出现了标志为特异场景的场景，就调用特异场景的创建方案。
为了方便的使用各种外部接口，大致可以设计继承结构如下
特异场景 : public 场景基类
模式化场景 : public 场景基类
场景基类 : public Layer
场景管理器 : public Ref
管理器中有如下方法
public:
nextScene(编号？名字？)
中间有SplashScene的调用
private:
Scene* createSceneWithSpecailLayer(参数们)
{
SpecailLayerX::create();
可以设置一个SpecailLayerMap?
}
Scene* createSceneWithUsualLayer(参数们)
{
Scene* createWith模式化方法
}
这就决定了DB一定是一个引用表，而每个场景独占单SD才是其核心部分。
但也有可能特异化场景也需要SD设置参数，不过问题是。。。使用的是何种SD？以及SD的设置方案？
通过以上的设计考虑，在ProcessOn上设计SceneManager为核心的数据层级结构

完成了层级结构的设计，主要方法应该标注一些，但那是睡起来以后的事了。。。
主要类方法
-Sys_Save

-Sys_Scene
private:
DB_Scene* _db;
DB_SplashScene* _dbs;
M_SceneScriptParser* _parser;
Sys_Save* _save;
Sys_UI* _ui;
DB_Scene*&SD_Scene包含的是有脚本在其中的SD，经过解析之后变成另一个类返回，即 NSSD_Scene*无脚本SD
DB_SplashScene*同理
private:
Scene* createSceneWithSD(NSSD_Scene*) 
{Scene* sc=Scene::create();NSSD->getType()? gamelayer=createSpecialLayer(NSSD)?gamelayer=createLayerWithSD(NSSD);
uilayer=getUILayer(NSSD_Scene*);addChidl(gamelayer);addChild(uilayer);}
M_GameLayerCommon* createLayerWithSD(NSSD)
{return GamerLayerCommon::create(SD);}
M_GameLayerSpecial* createSpecialLayer(NSSD)
{return XXXSpecialLayer::craete(SD);}
UI_Layer* getUILayer(NSSD_Scene*)
{return UI_Layer::reate(SD);}
Sys_Scene* create();
bool init();
public:
Sys_Scene* getInstance();
void nextScene(const std::string& name)
{SplashScene::createWithNextLayer(name);}
当SplashScene进入后，在OnEnter方法中调用getScene()
Scene* getScene(const std::string& name);
{getSD;_parser->parse(SD);createSceneWithSD;}

-M_GameLayerBase
public Layer
private:
bool _isPaused;
cCtrl* cameraCtrl;
Node*(WithPhysics) Border;
Node*(WithPhysics) cameraBorder;
UI_Layer* ui;
ListenerSet*(以Parsers和Dispatcher作为子节点形式出现)
LaEmojiPack*(即以浮动字形式出现的LaEmoji的预载，其运行可以被设为到何时自动移除，通常只有一页)
//也许使用类似AnimationPack中的HitAnimation的形式实现。
public:
update(float){_children->update(dt);}
Scene* createScene(NSSD);
bool init(NSSD);
void pauseUpdate(bool);
void pausePhysics(bool);
void pauseLayer(bool);

其中NSSD的考虑现在没有必要，使用脚本判断是非和单元添加生成的方式。
其余的设计还是有借鉴价值的。

要实现场景系统类，需要先实现Base场景类和其继承类。
突然发现问题，需要在DB_GameLayer中添加Border有关项目。
在DB_GameLayer中完成添加Border项目，下一步是仿照HelloWorldScene完成一个场景类的基类。
注意存留存档系统的接口。