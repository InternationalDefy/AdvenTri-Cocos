今天的目标是利用已有的HelloWorld类和上述的Scene体系，实现一个标准的GameLayer基类。

考察HelloWorld类的方法，包括。

1场景创建，2层创建，3更新方法，4按钮回调
其中，按照设计。
1应该由场景系统实现，同时配合对UI层的关联。
2应该由GameLayer自身实现，其派生类要拓展其派生方法。
3应该由实体类和各自的更新实现，但是场景类需要一个统一调用的函数。
同时，直接添加为场景类子节点的类，需要保证场景类的GetLayer方法返回的是自身。
4应该由UI层实现，在场景系统生成场景类时对UI进行分配以选择合适的UI，通过信息分发的形式实现两层之间沟通
（观察者模式）
2的具体操作包括：
A 主角类的生成 ，技能设置，位置设置。（存档关联）
B 敌人类的生成，技能设置，位置设置，入场设置。（实体系统和存档关联。入场时使用事件监听机制）
C 背景的设置。（场景类基础方法，由场景系统完成）
D 场景事件监听器注册。（场景类的基础方法，由场景系统完成）？有可能在特异化场景使用特异化处理。
E 物理事件监听器注册。（场景类的基础方法，由场景系统完成）？有可能在特异化场景使用特异化处理。

场景基类如此，场景系统在生成其时仍需使用SplashScene调用。
SplashScene的生成：
A 背景精灵的设置。（场景系统来设置?）
B 由SplashScene主控的Scene的创建。（由场景系统完成？）
C 在其中设置新Scene的对象。（将相关SD作为参数调用传入其中？）
对以上ABC三项进行考量，其实这里需要对场景类基类和场景系统设置友元。

*****************
以上为28日日志
*****************
今天的目标是以27 28 两日设计考量为蓝本，实现场景类的分级构建。首先完成GameLayer基类和SplashScene，完成的过程考虑两者和UI的关系。
以及友元设置的前提下，如何构建之。
场景的层级创建任务肯定要归于Sys_Scene完成，考虑以下问题：
不同的场景尤指特化场景需要特化的创建方式，不适应Sys_Scene的分派
现在开始完成GameLayer的统一生成方案。

突然发现一个问题：AI系统没有实现，控制器该添加一个新的脚本？来实现AI系统？这个希望可以在快速完成现在的模块后添加。

第一步是添加了场景边界的设置，但是Sys和场景系统并不是很完善，不能够通过显示场景的方法来看效果。
因为之后场景初始化都将是照猫画虎，现在的目标是尝试使用场景系统生成。

纠结于场景的生成和退出的自定义操作，考虑是不是需要在退出时执行特殊操作的支持。
同时考虑生成操作应该传入何种参数，这对Sys_Scene的要求不仅是应该可以实现进出功能，实现脚本调用，更需要实现在正确的地方使用生成方法，免于过分占用游戏时间。
在DB中加入定义，进出操作的模块。用DB_GameLayer
否，取消对GameLayer的EnterActionQuitAction的操作，其出入使用一般的动作实现。而其需要的一些特殊动画，使用EventListener在调用退场或入场方法时发动。

似乎类型不兼容？原来是没有实现SplashScene，现在可以先实现相对简单的SplashScene

实现过程中新决定的设计：
1 SplashScene改为SplashLayer 它是一个Layer子类，拥有创建只包含自身一个Layer的Scene的方法
2 SplashLayer GameLayer均有创建 Scene的方法，GameLayer在创建时添加UI层作为节点
3 SplashLayer GameLayer的init操作均有 Layer类自身完成，这是为了将逻辑整合在一起，Sys_Scene拥有调用两者的方法。
4 GameLayer在创建时需要创建UI层，但是。。。UI层的考虑->需要固定的设置？需要预设函数？需要脚本化？如何保证复用？如何提升创建效率?
5 脚本解析器类M_ScriptParser作为Sys_Scene的子节点被访问？否，可以直接访问。

初步实现了创建操作，但是很多部分需要存档系统库或者UI层相互结合。明天开始筹划存档系统。
*****************
以上为29日日志
*****************
今天要先实现一个存档系统，然后利用存档系统和其他系统结合完成场景类。（听起来有点遥不可及，但目标应该高远）
存档系统的实现方案？XML？CSV?
考察虽然一两行简单的代码就可以实现一个数据的存储和读取，但是一个完整的存档系统应该具备的是批量存储修改的能力，同时还要有很简单的分批能力。
考虑其他动作游戏在存档点时的存档操作，需要存储的信息包括：
主角信息：等级，经验，技能点，所装备的技能，物品栏信息
场景信息：当前所在的场景，场景物品的破坏情况，谜题解析情况，
实体信息：敌人的消灭情况，哪些敌人可以刷新，NPC互动状况，NPC消灭状况
额外信息：某种特殊点数是否触发，某种彩蛋是否遇见
游戏信息：游戏难度，游戏进度，游戏时间
存档系统需要一个能够执行批量分配存档信息的方案。
？同时也需要批量读取操作提供支持？
存档系统的实现目标： 
1 依据已有的存档单元设计
2 可自定义的批量存储
3 可自定义的批量读取
4 特殊数据的精确存储读取
5 多个存档栏位
6 存档清空操作
7 何时存档何种内容的外部调用接口

设计思路：
存档数据分为三个模块，两个大部分，
分别是：场景信息大部，非场景信息大部
场景信息模块，持有类信息模块，隐藏信息模块

何时存读？
存：打开自动保存则 每次切换场景存档。
手动操作点击存档。
读：加载游戏，切换场景时。

存档操作做什么：
当前场景的信息存储
非场景信息大部存储

以下以场景进入退出为例，语言化描述存档系统的想法

场景信息模块的存储和读取仅与场景类相关联，在其进入和退出或达到存盘点时进行读取存储操作。
场景需要存储实体状态，则需要一个std::map<std::string,int> 来表示
同时场景类在创建时给每个实体赋予一个Tag(std::string)在实体有自身情况发生时发送一个信息给场景类，由场景类负责修改其Tag
存读档操作用Tag的存读实现，同样的，场景在创建的时候需要初始化Tag以保证存档的延续性
同时各场景自身也需要一个Tag来进行场景间的区分。 有些存档信息需要传递场景之间，
场景信息存档的外部接口形式时 getSceneSave(SceneTag,EntityTag)(return int Stance)

非场景信息比如主角类信息，物品栏信息等，由自身类持有，并在场景进入时将其存档信息读取，并初始化为自身数据。
在场景退出时，将自身数据存取在存档系统中，以保持维序性。

已有设计的修改
DB_Scene
+string SceneTag
DB_GameLayer&SD_GameLayer:
+string SceneTag
+string(n1+n2) EntityTag
M_GameLayer
+map<string,int> EntityStance
+string SceneTag
M_Entity
+string Tag
M_Player
+M_Player* createWithSave();
+void saveFiles();

这里注意：已选对话选型的存储和读取？
对于NPC类，而言，其状态可以用？xy表示其对话选项为x&y?
Sys_Save
{
int Stance getSceneSave(string SceneTag,string EntityTag)
}
以此设计，尝试构建存档系统。

写了必要函数的声明们，晚上回来写定义。

考虑到有可能主角类等的数据存取需要对一个类进行操作，而这操作
1 需要对其他类的.h文件引用
2 可能会相当复杂
所以也许目前定义和声明的操作是文件中Sys_Save_Basic
而以后可能会添加Sys_Save_Player等

完成了存档系统的基础操作，以下操作尚未实现
1：存档系统与场景系统的联动
2：存档系统与主角类联动
3：特殊存档信息的清空
4：存档覆盖问题和需要添加的TalkBox
基于目前的考虑，可以先实现1