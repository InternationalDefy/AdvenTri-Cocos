1 需要组织一个UI层，一个场景添加两个层，Ui系统作为一个单例而出现，使用getInstance方法来获取一个拥有参数调用的合适的UI层
2 在Sys_UI中组织一个数据库DB_UI多层级逻辑结构。表示已有UI的实现材质和使用方案，有很多的注释行。而UILayer以及各种初始化图像。参数等的设置在Sys_UI中实现
3 载入页面也可以通过Sys_UI设置其形态，同时作为不同于UILayer的类LoadingScene出现，在MainSceneLoading时使用回调函数创建MainScene，但是。
效率问题未知，是否能双线加载资源未知。这里需要考虑：先做实验考虑其效率如何，如果不行，则只能手动双线程。
4？ 使用类似于对象池模式的方法处理场景类和UI层的互动。UI层对场景类是部分可见的，场景类持有UI层的实例指针。场景类对UI层不可见。UI层拥有部分public方法向其添加UI元件，可以被场景类调用。场景类中的元素，包括实体，逻辑实体等需要使用UI的场景元件持有UI系统数据库中的UI Set（实质是StringData）实体类对UI层不可见。场景类在创建实体时利用其UISet数据元 向UI层派发信息，并将其对应的指针传送给UI元件的构造器中作为初始化参数而使用。此过程可能需要由全局可见的Sys_UI来完成。
4？ 考虑观察者模式已经实现和游戏固有的信息派发机制：可以在场景层派发信息给UI层，在UI层的每一个元件创建并初始化时添加其监听器。如此设计需要考虑一个对话框的完全实现问题：通常情况下的表情表述更多的是在场景层的动作而非UI层沟通的实际UI，而对话发生时则进入对话框状态？这样不好，以为丧失了艺术性实现的可行性和灵活性。那应该如何保持UI层同步？又保证绝大多数UI逻辑在UI层中？
如果完全使用观察者模式实现，那么只要有UI实现，每个实体的每一步都需要信息的派发。效率堪忧。
5 很显然我们需要一个能够由脚本控制的类来处理 对话类，也许叫做 M_Speech 而，M_Speech应该是场景层的还是UI层的组件呢？

4 设计决定
使用观察者模式实现。
在游戏逻辑上是需要修改UI的操作，完全由UI层完成，其使用事件监听机制，用派发事件和注册监听器的形式实现场景层和UI的双向沟通。
场景类在完全实现的时候也可以将ListenerSet作为一个类而使用。
这里要注意维护一个事件信息表。记录不同事件的派发者和接收者以避免误操。

5 设计决定
普通的言语，类似FuckU之类的出现作为场景类的一部分而存在，属于实体的子节点。
场景需要一个对话状态，但不一定是对话框状态，而是对话触发状态。当前状态启动UI层的Controller，并且设置Swallow，实体层的Controller依然可以使用但是选取事件会被Swallow。操作实体离开则可以结束对话，以派发事件的形式使UI层DisableController，同时结束对话触发状态。
对话状态的进入和退出，牵扯到相机视角的变换，这里自然需要UI层持有主角类的指针，用以访问和控制相机控制器。相机控制器的外部接口有用啦！希望我还没删掉它。

*****************
以上为3日日志
*****************
当前阶段的问题：
1 UILayer的实现非常基础且简陋，我们还需要为其添加很多操作，还有sys如何构建
2 需要一个H-P体系？或者Handler单例？在Sys_UI中。
考虑到EnterAction并不会太多，其实可以单例实现，因为H-P体系还要考虑Enum等更新十分复杂。
ok现在先考虑问题2 不考虑layer的拓展修改，来实现EnterAction QuitAction ResponseAction的设置。
可能需要添加enum，修改csv。
注意！EnterAnimation属于Menu，而独有的动画Enter Quit Response都属于Item的Sprite。
添加了H-P体系，这里考虑？是否这个体系可以归于一个？
当然会一定程度的属性受限，但是可以极大的简化操作。
刚才在编译中出现了类未定义的问题。
究其原因是，使用的类虽然定义了并且include了对应的头文件，但是其中的组件类没有include相应的头文件。
实现了一个handler但是没有完善统一的handler，现在考虑用handler对MenuAction进行设置。
在item和menu级别修改动画的设置关系并测试。

UILayer尚缺几乎所有操作并且不易分辨和Sys的关系，但是可以在添加基本属性和操作来实现测试。

今天成功实现了基础UIlaye类和H-P体系之下的双层动画设计，实现了Menu和Item类（除事件监听）
明天将目标放在Layer类的完善上。

*****************
以上为10日日志
*****************
昨天迈进了一大步，但现在还不是高兴太早的时候，今天的目标是完善layer未定义的操作。
修改昨天的操作，现在需要的一个实现是？等menuenter结束了再itementer？
将H-P体系的Callfunc改为FiniteAction计时器和Callfunc的组合可以实现，效果拔群。
1 考虑到UI体系有打开和关闭两种形式，所以Menu不仅需要EnterAction还需要quitAction，已有的体系可以很好地handle，但是命名有问题。
先完善Layer 和 Sys？还是先完成QuitAction？
决定！先完成QuitAction。
增加了DB的内容拓展，修改了Enum变量名。还需要
1 修改ParserHandler类名和文件名
2 添加GetQuit操作。
先进行1 1完成 2 完成 现在完善quit操作的动作。
Menu的进入操作应该包含setVisible，退出则不包含（由item或Parser等实现）
实现了坐标系转换操作，现在的进入退出操作存在以下疑惑？
1 是否应该在sys中处理此类问题
2 没有进入退出操作中阻断
3 没有合适的初始化机制
4 不确定是否完善了内存管理
5 没有正确的设置LocalZOrder

有bug，闪现，其实是因为Item层面错误的设置了Visible。
应该在设计上对其解耦
Menu处理visible 有自己的基础Action item处理Event Sprite处理Action
解决闪现后发现Item形态怪异
动画包设置问题。可以以后修改。

现在处理以上五个问题
1 3 4 设计决定！因为每个关卡所使用的UI只有一套，所以在关卡开始的时候预加载如Layer中。目前不由Sys控制，目前不实现。
5 在DB中修改并处理。
因为Menu的开关和Zorder处理已经被移动至UILayer处理而非UIMenu，故EnterInstance和LocalZOrder项给M_UIMenu使用而非SD。
实现5
2 在Menu？或Layer？中添加控制项。
layer的逻辑已经够多了？menu的逻辑不多且不复杂？
问题不在于逻辑的多寡，而在于时间点的把控，在哪个类里添加操作可以直接在开始控制的时候就阻断？
UIlayer作为标志位处理的是Vec和Map，其准确性不对，在删除时直接使用也会造成困惑。
修改其时间即可？尝试。不行，会在Vec造成重复访问。
在Menu中添加控制量？尝试。加入_state控制。成功！