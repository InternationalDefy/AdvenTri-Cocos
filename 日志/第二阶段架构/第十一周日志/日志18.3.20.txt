恶心的操作系统作业阻滞了两天的进程，今日开始不能再拖了要开始设计物品系统并逐步实现之。

物品系统的实现必须有以下几个元素
1：物品栏 2：逻辑物品类 3：实体物品类 4：物品存档系统
其中 
1：有一个实例被实体所持有，其包含一个Map？Vector？管理物品在背包或者装备栏里的位置，需要和UI结合。也许Sys_Item提供一个UI访问方法？
注意物品栏和存档系统相关还和State相关，使用

2：物品类的内存储形式，拥有物品调用方法的指针，和物品方法紧密相关。需要DB SD。是否需要实体？如果记录，是数据形式还是实例形式？
A 持有对使用方法函数 的调用记录
B 有DB 和SD来定义行为
B 需要一个Drop操作。
C 需要一个拓展方法体系
D 持有对实体物品类的记录，应当是string形式的名称，std::string _dropItemEntityName

3：物品实体在 使用 丢弃 捡拾 等操作时所需要和游戏场景及其他实体互动的实体。
继承自Entity类，属于I Entity
A 三种操作并不使用同一实体 
B 需要不同的函数操作如判断捡拾 碰撞判定碰撞回调函数等
C 需要一个可以供其余实体访问的创建方法，有自己的DB SD 
D 最终问题回归到其他实体系统中 有自己的PhysicsBody和对应的回调方法 在EvePhysics中定义和记录。

Sys_Item 持有 DB_ItemState逻辑物品数据库实例 DB_ItemEntity实体物品类数据库实例
以后还需要持有存档系统实例？
提供创建对DB中SD实例数据的访问用于创建逻辑类或实体类的实例
提供物品栏UI更新和存档系统的访问方法
有效的外部操作直接访问Sys而非DB
提供利用SD构造逻辑类以及实体类实例方法，即拥有解释器实例
先从DB开始构建。

思考：DB_ItemState DB_ItemEntity SD_ItemState SD_ItemEntity需要持有哪些数据
以下的Animation仅指Item所使用的而非Entity使用的
SD_ItemState 
//有一些属性可能要在UI系统中使用，比如鼠标移上去之后的播放声音，或者Texture显示以及变化。
//还有一些属性和逻辑操作有关系，如usingAnimation dropCallfunc等需要在M_ItemState中实现，也许需要数据元定义。
string Name,string UiSetName,string EntityName,float usingTime,string usingAnimateName,drop callfunc(可以为Default) numberOfDropCallfuncparam params,numberOfuseCallfunc(k) 以下1->k int UseCallfuncUseCallfuncType,NumberOfParam,ItemCallfuncType[i] params,
SD_ItemEntity
string Name,string TextureName,string StateName,string PhysicsBody,float dropDelay,string dropAnimationName,string flyingControllerName,string FlyingEndCallfuncName,int Numparams,1->p params,

实现了SD_ItemState SD_ItemEntity DB_ItemState DB_ItemEntity

*****************
以上为19日日志
*****************
今日参照19日的设计开始实现物品逻辑类和实体类的模型的实现，先构建一个可以使用的Sys管理类和一个可以用来调度的Handler，Parser。
使用类似于EventSys的处理方法。

思考Sys应该具有的方法和需要实现的操作。
依据定义里的繁复数据创建除M_ItemEntity和M_ItemState的方法，DropCallFuncHandler?UseCallFuncHandler?FlyingEndCallFuncHandler?访问谁？谁持有？

M_ItemEntity,M_ItemState持有一个Action* _callfunc 在创建以及初始化时由Handler创建，Handler也通过调用不同数目的Parser，把CallFuncBind到一个Action*上
Handler由Sys持有，Parser由Handler持有，不是静态类或静态方法，动态但是类似于？单例？
需要设计三个Enum表示其类型。
设计了三个Enum以及string的转化函数，可以在Enum中拓展。
下面要实现一个Handler和Parser的双类体系，先从DropCallFunc开始
从Callbacker的体系里尝试改制，但是它们的运行方式是不同的，一个作为子节点添加而存在因为实现的目的比较复杂，而另一个则是添加函数而存在。
重新考虑DropFuncParser应当拥有的虚方法。
本质上是单例？那需要提供一个创建方法而初始化？Nope？需要有一个添加方法倒是。
架构更改并初步搭建，问题如下：
1：目前尚未创建合理的M_ItemState类所以添加操作不甚确切。2：尚未有拓展体系的出现。