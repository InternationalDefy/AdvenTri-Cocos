重新考察了Controller类，数据部分和模型部分的分离不够彻底，准确的说是Controller自身的创建都需要使用SD，而非直接由SD创建出Controller类的实例，这个问题目前看来没有必要去解决，但是需要记住并注意，M_pCtrl类则需要重新以SD创建的形式构建。

Controller类有一个巨大的问题：Active和set是同步的，这个问题的解决方案：将Active和Set分离成两个函数。它们存在调用的问题：
1：何时调用？2：如何调用？3：由谁调用？
1：激活控制器时调用，可以时实体创建的那一刻，也可以是触发事件或者脚本触发调用
2：通过函数setActive()
3：实体？控制器？
由实体访问控制器的Active操作。现在对实体添加Controller使用SetController操作，控制使用ActiveController操作

目前先使用这个缝补方案，Entity类似乎需要一定程度和数据类解耦。

通过实验，发现所有的EventDispatcher使用的是一个，所以可以直接注册，为所欲为。

下午考虑的问题，利用WindowsAPI添加左右键监听。
楼上放屁！
经过实验，发现可以其实cocos有对右键的响应，使用event->getMouseButton（可以返回其值），0左1右，也有宏可以方便调换。

现在发现的巨大问题是：控制器系统可能要重写！

1：Controller类没有足够的对其他外部变化响应的回调函数。
2：M_pCtrl的方法不能再Controller作为父类的setController，ActiveController方法中使用。
3：delay->update的方法很难适应所有的Entity

1：基类里添加注册方法，派生类实现注册方法，可以响应外部变化的回调
2：基类中注册没有任何行为的虚函数即可
3：值得思考的问题，亟待改进，解决方案有
（1）分离delay->update（active）与创建控制器的操作
（2+）没想出来  /  。\

基本实现按键监听，问题有2：
1：key目前没用
2：按钮会swallow mouse event 的 down 操作
感悟：UI以后要自己写不能用它的menu？&&开启菜单层时要注意对listener的disable
1楼2楼傻逼！
1：没有开按键监听的函数
2：没有swallow
感悟：还行，反正UI层也打算手撸。

现已实现按键监听，注意key值和mouse值设计，晚上做回调函数。

着手于对不同key的回调设计，想法有以下几点
1：注意对不同操作的分离，一个函数体应当只有对一种情况的一段操作的函数
2：为了实现以上目的，可以使用多个辅助类来割裂其操作，在一个函数体内书写则要注意对情况的命令模式分离
3：很有必要创建一个Map来记录按键情况，但是，bool值又不支持，
可以想到的两个解决方案：1：bool字符数组，表示其关系，2：Mapstring对类，类只含bool

转到CC EventKeyboard的源代码，似乎可以对其按键情况进行监听。

发现把KeyCode里的Class去掉 可以使代码得以使用bool数组，实现按键情况监听，似乎仍可以实现其功能，其它问题未知，先这样做，并记录。

修改结束，明天做回调函数。

*****************
以上为4日日志
*****************

通过实验看键盘值监听
1：大小写不分 2：LCTRL RCTRL LSHIFT RSHIFT区分

通过实验看鼠标监听 
getCursor可以直接返回到GL系里的窗口XY值

以下构建一个控制系统，需要考虑的问题如下：
1：鼠标移动控制转向
2：键盘按键控制移动
3：shift space开启技能模式
4：左右键的攻击键

逐一思考其解决方案：
1：可以利用预先工程里的资源，先进行尝试。

发现问题：之前的Amor所以跟随Entity是因为addChild了，和update无关。

mouse的Rotation已经设置完成，正右方是0点且标准的设置函数在M_pCtrl中有之。

2：键盘控制移动
需要考虑的一个问题：是否使用可更改的存档按键。
-写死并不是一个很大的问题 
-拓展按键和修改可能会妨碍到UI的简洁性。
？多按键和手柄支持可以用宏实现？
决定使用宏实现。
现已使用宏实现，并将force改为Impulse形式，在update里施加，此种方法：
+解决了暂停使用的问题  +便于修改按键  -现阶段操作手感异常蛋疼 +数据修改可以调整之

这里的实现是比较优雅的。技能可以用类似的形式，调用时使用_pressed[keycode]访问。

开始对Player类的技能类进行设计，设计具体见ProcessOn

现在一定要开始技能模块的数据核心了。

需要实现的包括：
1：不同等级的技能对同一技能方法进行不同参数的调用
2：参数需要一定的可调整性，以避免在数值调整时过多的重复编译
3：每个技能实现不同的功能，使用不同数量，不同类型的参数
4：可能需要一个解析系统？（如果技能数目有限则可以手动实现）

依据存档系统或初始化设置pSkill的实例于m_player类里作为调用，skill的创建则由SD_pskill和DB_pskill完成。

实现playerStringData类，构建了Ref体系，目前尚未实现依据SD创建PSkill

pCtrl的继承有误，应当继承SD_Item

应该使用Items，因为SD所使用的不只是int，还有可能float，targetname等。

pSkill的数据库搭建已完成！