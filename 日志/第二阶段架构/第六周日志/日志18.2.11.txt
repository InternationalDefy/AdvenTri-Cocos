今天目标是建立一个摄像机系统，需要实现的目标：
1：使用runAction来控制摄像头的移动，在实体经过屏幕边缘后播放移动动作。
2：需要一些操作的解释器来控制摄像机的脚本移动，包括移动速度，移动始末位置，以及在任何时间都可以调用。

设计思路：
1：用一个M_cCtrl类进行摄像机移动操作并予以封装。
2：M_cCtrl应该具有默认控制方法 和外部访问操作。
3：默认方法使用脏标记。
4：和M_cCtrl为友元。
5：在Scene创建时创建并初始化，持有Scene的Camera的引用。

考虑：有必要p和c相互持有吗？似乎c持有p即可，p无需？访问c的数据？
放屁！都需要访问！可是堆栈会降低效率，所以直接访问？

目前实现了依据Pctrl设置camera位置
剩余两个问题：
1：何时何处优雅地创建cctrl
2：还有cctrl对pctrl的view修正
3：还有cctrl对window边界的处理

vc\include\xmemory0(592): error C3130

修改debug配置之后，问题解决。

再加上高度设置动画，考虑到可能会有场景缩放的问题。

对于Pctrl的兼容设置：
1：需要一个真实的mousepos
2：公式？

解决1：设置一个Radio于cctrl中

问题23解决，创建可以利用脚本。这个需要场景类的分析器，或者一个数据库？

今天任务完成！

*****************
以上为9日日志
*****************
今天把摄像机左右边界的移动锁定改为bool的形式，这样在镜头高度改变时不会造成bug误移
设置方法上每移动一个屏幕要使用函数setBorderLimited设置，可以用事件监听机制实现，也可以在场景初始化时设置参数。

今天要着手于事件监听系统的实现，先在ProcessOn上进行设计，考虑一下问题：
1：事件监听机制如何与已有事件系统结合。
2：监听机制的核心：谁在监听，监听谁，监听何种行为，如何发送消息，如何响应消息，

设计思路：先研究Cocosd原带的事件机制。

在网上和书中的学习有以下几点需要注意的地方：
1：内存删除的方法：
for循环中找寻，如果找到，erase，break，出来release
2：在场景切换时要注意即时移除eventdispatcher

重读设计模式，这里考虑一个问题：
状态模式也许可以更好的解决实体行为的事，这里因为实体

ProcessOn上设计不能够满足我了，在纸上铅笔画。