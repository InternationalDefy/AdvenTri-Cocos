先行测验上次内容的实现程度，今天考虑移植到Enemy类以及NPC的构建？
经试验真是酷毙了！

现在考虑拓展方法的记录和Enemy类的移植

拓展方法：
1：当需要添加一个新的PlyaerState状态类时
A 在Ref_State中注册.h头文件
B 先实现对应的Player类方法，可能需要添加新的技能类，在.h文件和activities.cpp中
C 继承自M_PlayerState基类，修改需要注意的派生方法
D 具体的ExitTo配发方法在M_PlayerState基类中有所描述，不同的exitTo可能需要getPlayer考虑初状态和目的状态的设置
E 退出State的方法需要实现的目标比较繁杂，Gather的ExitTo要调用技能的释放，Use的ExitTo要考虑M_Player当前的互动对象等
F 退出State的操作同时需要实现动画和逻辑的修改更新。进入State的操作也需要动画和逻辑的修改和更新。
2：技能类的拓展方法
A 在Ref_State中注册.h文件
B 在分拣类SD_PSkill中注册分拣方法
C 添加技能类继承自M_pSkill，写create函数
D 重写Init和active方法，

现在考虑给Enemy类添加State：
先考虑：
Enemy类需要添加State吗？
从必要性考虑：
一些Enemy确实会进入不同State以使用不同方法，比如重装兵可能会进入DefenseState 法师会进入GatherState 盗贼会进入DashState，
同一个敌人类实体的行为没有主角类丰富，所以一种实体的进入State通常只有一种。
如果一个实体使用最多一种State，完全可以使用bool StateOn来判断其类型和回调。
但这样又会有在Enemy类大量bool State出现，而且它们可以响应不同类型的回调却难以驱动不同的行为。
派生类是一种实现的方法，其一种派生类拥有一个bool onState，也可以定义Enum类 AdvenTriEnum::EnemyState 在Enemy基类中持有其实例，其可以驱动行为。但相当复杂。

最终决定继续使用类似于PState的实现方法，现在的问题是
1：Controller的update方法不能够实际起到作用，最好修改。
2：ControllerAI和ControllerSimple都需要重新一个实现方法。
3：这里需要在Controller里实现脏标记模式的使用。
4：需要一个EnemyState类，控制对State的分发。
5：EnemyDebuff类更加复杂，因为Amor Weapon也要考虑其特效。

考虑完了，下周再实现！

*****************
以上为11日日志
*****************
先为实现技能类的内存管理考虑了一阵，直接去掉addChild即可。。。
修改Controller类从名字开始，把无用的操作也需要修改。

修改方法：把entity在执行操作的判断方法改到了Controller类中，这样可以在C和M上解耦。

同时把Move操作和Update剥离开来，在Update中判断是否在执行操作以控制时间间隔。
