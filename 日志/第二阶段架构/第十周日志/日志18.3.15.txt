先行测验上次内容的实现程度，今天考虑移植到Enemy类以及NPC的构建？
经试验真是酷毙了！

现在考虑拓展方法的记录和Enemy类的移植

拓展方法：
1：当需要添加一个新的PlyaerState状态类时
A 在Ref_State中注册.h头文件
B 先实现对应的Player类方法，可能需要添加新的技能类，在.h文件和activities.cpp中
C 继承自M_PlayerState基类，修改需要注意的派生方法
D 具体的ExitTo配发方法在M_PlayerState基类中有所描述，不同的exitTo可能需要getPlayer考虑初状态和目的状态的设置
E 退出State的方法需要实现的目标比较繁杂，Gather的ExitTo要调用技能的释放，Use的ExitTo要考虑M_Player当前的互动对象等
F 退出State的操作同时需要实现动画和逻辑的修改更新。进入State的操作也需要动画和逻辑的修改和更新。
2：技能类的拓展方法
A 在Ref_State中注册.h文件
B 在分拣类SD_PSkill中注册分拣方法
C 添加技能类继承自M_pSkill，写create函数
D 重写Init和active方法，

现在考虑给Enemy类添加State：
先考虑：
Enemy类需要添加State吗？
从必要性考虑：
一些Enemy确实会进入不同State以使用不同方法，比如重装兵可能会进入DefenseState 法师会进入GatherState 盗贼会进入DashState，
同一个敌人类实体的行为没有主角类丰富，所以一种实体的进入State通常只有一种。
如果一个实体使用最多一种State，完全可以使用bool StateOn来判断其类型和回调。
但这样又会有在Enemy类大量bool State出现，而且它们可以响应不同类型的回调却难以驱动不同的行为。
派生类是一种实现的方法，其一种派生类拥有一个bool onState，也可以定义Enum类 AdvenTriEnum::EnemyState 在Enemy基类中持有其实例，其可以驱动行为。但相当复杂。

最终决定继续使用类似于PState的实现方法，现在的问题是
1：Controller的update方法不能够实际起到作用，最好修改。
2：ControllerAI和ControllerSimple都需要重新一个实现方法。
3：这里需要在Controller里实现脏标记模式的使用。
4：需要一个EnemyState类，控制对State的分发。
5：EnemyDebuff类更加复杂，因为Amor Weapon也要考虑其特效。
*****************
以上为11日日志
*****************
今天首先要实现Amor对Debuff和伤害种类的响应。
将伤害种类，Dbuff时间，和伤害Debuff分开处理。
也许需要记录一个完善的AnimationPack需要什么。
决定了，Amor不处理Debuff状态，其与武器不同。
使用None来处理Amor的消亡，动画控制也因为NONE的设置而阻断。
现在Amor已经可以正确的运行了。Debuff和Damage应该得以解决。
但是AnimationPack的设计很需要记录下来。
下面考虑Controller和完善体系的结合以及AIController的构建。
同时完善添加并完善E State
首先沿用Player类的设计。
这里需要一个保证来控制技能系统不至于崩溃，但是用两个保证显得多余，
一个是实体State的保证，一个是AI控制器的保证。设计上考虑：A 敌人类技能需要冷却时间么？ B 控制器可以访问冷却时间么？
*****************
以上为14日日志
*****************
接14日，先修改技能和控制器的实现方案。
将技能的冷却交给控制器处理，而不是State，只有在技能Ready之后 AI控制器才有可能向State派发技能指令，但是Simple控制器也可以直接派发技能指令。
只要派发给State派发了技能指令，则其进行状态转换并一定会发动技能，SkillReady仅给AI控制器作为估值参考指标。Simple则通过合理得当的设计使得不出现错误的技能派发。不准备给Enemy类Item系统。Blink 操作不会改变EState而且需要参数Vec2所以不把它和State结合，直接在控制器中提供访问。
Controller类中一定需要加入一个Target值，这个值会处理技能的对象 目标。

现在需要：
//1：给Enemy类添加Dash技能，作为测试使用
//2：修改Controller类并添加能够访问Vec2 _targetPosition
//3：利用新修改的Controller类完善Enemy类行为。
部分完善了，但是很不错了。
4：在修改过程中记录拓展方法。
