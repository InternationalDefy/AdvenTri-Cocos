1 需要组织一个UI层，一个场景添加两个层，Ui系统作为一个单例而出现，使用getInstance方法来获取一个拥有参数调用的合适的UI层
2 在Sys_UI中组织一个数据库DB_UI多层级逻辑结构。表示已有UI的实现材质和使用方案，有很多的注释行。而UILayer以及各种初始化图像。参数等的设置在Sys_UI中实现
3 载入页面也可以通过Sys_UI设置其形态，同时作为不同于UILayer的类LoadingScene出现，在MainSceneLoading时使用回调函数创建MainScene，但是。
效率问题未知，是否能双线加载资源未知。这里需要考虑：先做实验考虑其效率如何，如果不行，则只能手动双线程。
4？ 使用类似于对象池模式的方法处理场景类和UI层的互动。UI层对场景类是部分可见的，场景类持有UI层的实例指针。场景类对UI层不可见。UI层拥有部分public方法向其添加UI元件，可以被场景类调用。场景类中的元素，包括实体，逻辑实体等需要使用UI的场景元件持有UI系统数据库中的UI Set（实质是StringData）实体类对UI层不可见。场景类在创建实体时利用其UISet数据元 向UI层派发信息，并将其对应的指针传送给UI元件的构造器中作为初始化参数而使用。此过程可能需要由全局可见的Sys_UI来完成。
4？ 考虑观察者模式已经实现和游戏固有的信息派发机制：可以在场景层派发信息给UI层，在UI层的每一个元件创建并初始化时添加其监听器。如此设计需要考虑一个对话框的完全实现问题：通常情况下的表情表述更多的是在场景层的动作而非UI层沟通的实际UI，而对话发生时则进入对话框状态？这样不好，以为丧失了艺术性实现的可行性和灵活性。那应该如何保持UI层同步？又保证绝大多数UI逻辑在UI层中？
如果完全使用观察者模式实现，那么只要有UI实现，每个实体的每一步都需要信息的派发。效率堪忧。
5 很显然我们需要一个能够由脚本控制的类来处理 对话类，也许叫做 M_Speech 而，M_Speech应该是场景层的还是UI层的组件呢？

4 设计决定
使用观察者模式实现。
在游戏逻辑上是需要修改UI的操作，完全由UI层完成，其使用事件监听机制，用派发事件和注册监听器的形式实现场景层和UI的双向沟通。
场景类在完全实现的时候也可以将ListenerSet作为一个类而使用。
这里要注意维护一个事件信息表。记录不同事件的派发者和接收者以避免误操。

5 设计决定
普通的言语，类似FuckU之类的出现作为场景类的一部分而存在，属于实体的子节点。
场景需要一个对话状态，但不一定是对话框状态，而是对话触发状态。当前状态启动UI层的Controller，并且设置Swallow，实体层的Controller依然可以使用但是选取事件会被Swallow。操作实体离开则可以结束对话，以派发事件的形式使UI层DisableController，同时结束对话触发状态。
对话状态的进入和退出，牵扯到相机视角的变换，这里自然需要UI层持有主角类的指针，用以访问和控制相机控制器。相机控制器的外部接口有用啦！希望我还没删掉它。

*****************
以上为3日日志
*****************
今天的目标是实现UI类的时间监听机制，先考虑如下问题：
1 监听在何处实现？
2 监听的实现形式？
3 监听在何时注册？
4 监听何时取消注册（但保证不删除）？
5 监听在何时实现？
1 Item？menu？
Item！

3 添加到Layer以后注册？
4 移除Child的时候处理取消注册？
那需要一个Listener容易，和注册Listener容器。

2 使用EventSystem实现监听的创建和注册？需要添加几个新的注册器类。

5 监听在监听元创建时实现，但是不直接注册，要注意retain，release的操作。

现在考察Sys_Event考虑是否有需要完善和扩展的地方。
给sys添加get操作，即获取操作但不setParent （？不确定是否需要不AssignListener）
在测试类中测试removeFromParent以后CallFuncHanler如何操作。
DispatchHandler和CallFuncHandler没有正确的移除。重载Remove函数尝试。

在Entity中添加了DiapatchHandler和CalbackHandler，但是没有成功编译，现在的问题非常大。。。一下午都耗在了这一个bug上。

今天只要能完成debug，实现重载的remove就可以，明天再考虑listener对UI_Item的添加操作。

将Vector改为std::vector，问题解决。
在callbackParser类里增加stringdata类成员，可以在非sys环境中使用assign开启调用listener

关闭BSCMAKE之后继续Debug
终于完成了删除Dispatcher的机制！！！

*****************
以上为12日日志
*****************
身体的不适带来了两天的停工，但是不能够一直摸下去啊。。。这周一定要完成UI部分，下周就要开始场景和AI了。再下来是存档系统和菜单界面设计。RoadMap什么的，多少也应该重视一下了。
看12日日志，UI部分和事件监听机制实际上存在着相当明显的问题：
1 事件监听的实现对象是Node类，但实际上一般的Node并没有事件管理机制，如果添加其中，虽说场景变换时可以在Sys中刻意清除不必要的Listener。
但是单Node的移除 并不能使Parsers移除。所以这 1 造成不必要的事件监听和资源浪费 2 极大可能对已经被移除的Node访问，造成崩溃
2 事件监听通过派发某个名字的Event实现，但是其本质上并没有特异性。Event的内容也许可以有所不同，但这并不能在Listener层面被识别出来。
使用同一类Breed的Entity派发的事件均属于一个名字所能取得的DBEvent的索引，实质上无法辨析。
使用不同类的Breed的Entity派发的事件也可能因为事件名字索引相同而派发出仅仅是事件所传递的参数不同，但是事件名称相同的情况，在Listener层面难以辨析。
由此，极大可能性会出现 冗余的派发和不必要的整体性回掉事件。
基于以上问题，考虑到事件系统已经和众多Entity以及UI深度集成，但是却和Node类 Layer类集成相对较少。
修改Sys_Event所付出的代价相当昂贵，但是在Node和Layer层面增添新的方法就显得可取的多。
这样看来，UI和实体要实现完全不同的两类监听模式。
UI的监听是直接使用Sys_Event而实现的，而实体的监控则需要将绝大多数逻辑整合到场景类所添加使用的Listener中。
注意：
UI的数目极其有限，所使用的监听也可以具有很强的独特性。
实体的种类有限，但是使用Breed分类创建的机制意味着独特性只能是种类间实现的而不能是个体间实现的，同种类不能够发生同一种链式回掉函数，不然会使单一的事件发生X次（该类实体的当前实例数目）
所以，同一种实体，只能持有同一事件回链中的DispatchParser和CallbackParser中的一种，而使用特殊属性，分发特殊事件，实现特殊事件链式回掉的实体，在保证只拥有一个实例的情况下，可以使用完整回掉链的ListenerSet：使用情况举例！
可以实现的：
1 一类Rect有五个，他们到了一个山洞口，山洞里有吃Rect的怪物，五个Rect都发出EventCustom RectAtPass(void* this) 场景类拥有CallbackParser在接收到此事件之后，将void* this->Entity* e;e->gotEat();
2 一类Rect有五个，他们到了一个火山口，火山喷发对Rect造成火焰伤害，五个Rect都在火山口。场景类发出EventCustom VocanoBoom(void* position) Rect拥有的CallbackParser接受到此事件之后执行 void* pos->Vec2* pos; if (distance<X) (Enemy*)pNode->setOnHurtType;pNode->setOnHurtDamage;pNode->handleAction(AdvenTriEnum::EnemyAciton::HURT);
3 一类Rect有五个，他们到了一个火山口，因为火山喷发收到火焰伤害。另一个Rect是拥有另一个Breed，且只出现一次的Rect，它到了火山口就发生火山喷发，由事件机制实现派发和处理，所以使用另一个不同的Breed。