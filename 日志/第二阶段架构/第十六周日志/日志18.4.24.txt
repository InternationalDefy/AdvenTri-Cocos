果然还是要冷静才能够编程啊要把它当作一件神圣和幸福的事去做今天很无奈的在网上买了行李扎线想要加固电脑挂板但是坡扎线太厚了最后只能先放着再买了尼龙绳在寄到之前还是稳一些吧不用的时候把电脑放下来剩下的扎线到暑假带回家里吧还能用来骑行坤行李的不错么
对UI部分的编程成功告一段落，现在要考虑以下几个方向：
1 拓展 UI部分可以继续完善，通过层级性的拓展方法实现各种不同的UI种类，也可以对UI款式加以考虑
2 完善 实体层操作的完全实现方案，NPC使用Dialogue，即为实体层UI层的双向沟通。
3 开拓 实现另一个大的模块，关卡创建，以及存档系统
随机数好了。
等等，加权随机数
1 0.1 2 0.3 3 0.6
0.683  选3 说起来不加权也是3
真好呀。。。这一定是神的旨意。
好，既然是神的旨意，那现在先听一曲Maksim的Providenza

最近的目标是关卡创建部分，差不多十点半要关闭双屏状态给土豆录制视频。
要实现的关卡创建系统，包括的功能如下。
考察了帝国时代2的一些实现，可以采用的大致设计如下
1 背景设置 可以添加有变化的背景和带有动画的背景，那么就需要。。。AnimationPack？
2 地形设计 （实际上属于背景设置）其中一部分事件触发的逻辑由事件监听实现
3 事件机制 场景层面实现事件监听，可以添加触发事件的地点
4 单位设置和出现 Enemy 和 Npc类
5 固有实体和机关，依靠NPC类实现
6 镜头的运作和对话框的设计 靠UI类实现
7 靠SD和已有参数生成，可以使用数据拓展
8 要和存档系统有所关联
9 临近场景的进出，切换函数和方法
10 需要使用特异化场景的时候如何处理？
例如 BOSS站 体验关卡 创意关卡

这个类对其他类的依赖性相当之强。。。目前并没有更好的设计思路

*****************
以上为23日日志
*****************
划水到此为止，今天要开始着重于昨天思考之目标而实现设计。
1 背景设计：
背景必然分为两类，有实体的和无实体的，无实体称background，仅仅以Sprite形式出现，可以使用场景类直接定义
有实体的是NPC类，包括破坏，事件分发，对话进入等功能在其中实现，以M_NPC形式出现，使用场景类定义其name来创建
2 地形设计：
（？）地形实际上是Sprite材质+逻辑函数监听的集合，可以通过以下逻辑方法实现？Terran类？通过脚本形式添加范围监听？
一个场景需要设计一个边界值，这个边界会阻拦实体的通过，可以以PhysicsBorder的形式实现
3 事件机制：
利用已有的事件机制实现派发事件，使用ListenerSet进行事件派发的设计，对于每个Entity设计不同的CallbackParser
每一个场景持有自己独有的ListenerSet
在内存管理机制上，重写GetLayer函数，return自己。
4 单位设置：
一部分实体可以直接以开始时设置的形式，在场景初始化时进行设置，在需要其运行的时候打开其控制器。
一部分体需要依靠脚本创建，故不在开始时加载素材，靠事件触发将其出现，并播放入场动作即Enter方法。
5 类似机关和动态：
依靠NPC类实现，但是为了区分机关类NPC和对话类NPC应该在SD中把他们分开定义。
6 运镜及UI
场景类必要持有cCtrl实例，运镜操作时逻辑暂停（由场景类实现）
UI类也需要调用场景的逻辑暂停。
7 SD定义
目前尚不清楚具体的SD设置方法，但是
可以毕竟肯定的是需要使用一个引用表，而其余文件则都是单文件表示一个SD因为场景类内容太多。
8 存档系统关联
存档系统和场景的创建初始化相关，例如存档得到善恶值来判断创建风格，可能会因为一个数值的不同创建截然不同的场景
而且需要使用的存档系统值将不只是善恶值，可能在之前遇见的一些事会触发不同的场景设计，
此处仅指场景设计上的不同，当然也有可能出现这种情况：同一NPC说的语言不同，而非不同的NPC，这个问题可以给NPC类以及其DialoguePack处理
但是最好的处理方案是将 与存档系统沟通的内容 集成在 一个系统 中实现，那场景类就是最佳选项了。
在SD？DB中需要一个脚本解析系统（该来的终究还是逃不掉了）
9 进出以及切换方法
需要提供其余场景类可以调用的外部接口，SplashScene的处理方案等 故一定需要一个enter quit函数作为外部接口
而且本场景可能使用 不同的退场方式， 退至不同的场景，这些可以作为enter quit函数的参数调用
10 特异化场景的实现
需要一个场景管理器类，其管理场景的生成和切换，以及通过SD设置不同的UI之类的操作 
如果出现了标志为特异场景的场景，就调用特异场景的创建方案。
为了方便的使用各种外部接口，大致可以设计继承结构如下
特异场景 : public 场景基类
模式化场景 : public 场景基类
场景基类 : public Layer
场景管理器 : public Ref
管理器中有如下方法
public:
nextScene(编号？名字？)
中间有SplashScene的调用
private:
Scene* createSceneWithSpecailLayer(参数们)
{
SpecailLayerX::create();
可以设置一个SpecailLayerMap?
}
Scene* createSceneWithUsualLayer(参数们)
{
Scene* createWith模式化方法
}
这就决定了DB一定是一个引用表，而每个场景独占单SD才是其核心部分。
但也有可能特异化场景也需要SD设置参数，不过问题是。。。使用的是何种SD？以及SD的设置方案？
通过以上的设计考虑，在ProcessOn上设计SceneManager为核心的数据层级结构

完成了层级结构的设计，主要方法应该标注一些，但那是睡起来以后的事了。。。
主要类方法
-Sys_Save

-Sys_Scene
private:
DB_Scene* _db;
DB_SplashScene* _dbs;
M_SceneScriptParser* _parser;
Sys_Save* _save;
Sys_UI* _ui;
DB_Scene*&SD_Scene包含的是有脚本在其中的SD，经过解析之后变成另一个类返回，即 NSSD_Scene*无脚本SD
DB_SplashScene*同理
private:
Scene* createSceneWithSD(NSSD_Scene*) 
{Scene* sc=Scene::create();NSSD->getType()? gamelayer=createSpecialLayer(NSSD)?gamelayer=createLayerWithSD(NSSD);
uilayer=getUILayer(NSSD_Scene*);addChidl(gamelayer);addChild(uilayer);}
M_GameLayerCommon* createLayerWithSD(NSSD)
{return GamerLayerCommon::create(SD);}
M_GameLayerSpecial* createSpecialLayer(NSSD)
{return XXXSpecialLayer::craete(SD);}
UI_Layer* getUILayer(NSSD_Scene*)
{return UI_Layer::reate(SD);}
Sys_Scene* create();
bool init();
public:
Sys_Scene* getInstance();
void nextScene(const std::string& name)
{SplashScene::createWithNextLayer(name);}
当SplashScene进入后，在OnEnter方法中调用getScene()
Scene* getScene(const std::string& name);
{getSD;_parser->parse(SD);createSceneWithSD;}

-M_GameLayerBase
public Layer
private:
bool _isPaused;
cCtrl* cameraCtrl;
Node*(WithPhysics) Border;
Node*(WithPhysics) cameraBorder;
UI_Layer* ui;
ListenerSet*(以Parsers和Dispatcher作为子节点形式出现)
LaEmojiPack*(即以浮动字形式出现的LaEmoji的预载，其运行可以被设为到何时自动移除，通常只有一页)
public:
update(float){_children->update(dt);}
Scene* createScene(NSSD);
bool init(NSSD);
void pauseUpdate(bool);
void pausePhysics(bool);
void pauseLayer(bool);

-M_SceneScriptParser
此类的实现依赖于Sys_Save;
public:Ref
void NSSD_Scene* parseSDScene(SD_Scene*);
void NSSD_SceneSplash* parseSDSceneSplash(SD_SceneSplash*);
?void NSSD_UILayer* parserSDUILayer(SD_UILayer*);
？不确定上句是不是需要，因为它可以被SD_Scene定义，经转换成为NSSD_Scene由Sys_Scene使用
