观察ProcessOn上的设计内容，使用物品状态的实现还要依赖于一套物品系统。

目前先屏蔽其实现的细节，考虑状态类的统一规划：

这几类状态的退出都是进入Dash或者Standred状态，而开启都是从Standred状态进入，故而onEnter onExit操作不必考虑其状态的来源，只需做到制定的操作。
状态持续时间可以用内部计时器实现，在终止状态时或退出状态时删除内部计时器，或者有其他判定条件的检测函数，均考虑其中。

Player类State类的持有关系？State类要处理各种不同的状态所以静态类难以正确的Handle，似乎可以，但是在State的数量扩展的时候以及一个State需要一个计时器，这个不能够消除。所以不能使用静态存在方式。则使用？相互持有的关系？否。State类作为Player的子节点出现，持有Player的指针？可以。只要不是子节点都行。
创建操作？计时器？在State基类中实现。

子节点就算了，Player类可以直接持有？在使用时替换即可。
Nope应当作为子节点出现。

突然发现很多类都没有正确的Destructer，也许需要多用些功夫重写。在游戏开始实际运行之后。

今天完成了PlayerState的基类
1：派生类方法尚不明确如何实现
2：很多destructor没写，估计要补是个大工程，等State和NPC完成后。

*****************
以上为4日日志
*****************
最难办的事来了，目前的HandleInput操作似乎和我HandleInput的体系不一样。。。修改？不修改？
如何实现不修改的方案？修改该如何修改？

再看书，还有一个问题是具体操作的实现
比较具有可行性的一种方案是：
1：update函数中判断时间的缩进（避免计时器的混淆）
2：对不同行为仅有调度作用并不是以直接操作其内部逻辑的形式出现。
如 访问player->useItem（） 但不定义 useItem（）的内部代码

父子类等级结构现在已经完成，加入了StateTag方便判断退出和来自何种状态以决定使用何种函数

考虑：
1：Enter和Exit操作应当各司其职不要越权，但是又难以判定其删除与被删除的关系，所以是否需要在player类中执行其转换操作？还是把它作为子节点来自行执行转换操作？
2：是否要创建一个Enum操作类，表示实际操作而非直接输入？

问题1：
++这样可以有效避免进出双操作的耦合
+这样可以增强可读性
--这样会使handleInput操作意义不明
-编写的逻辑难度较高
-会破坏state和Player应有的层级结构导致越权访问？
倒是不会导致越级访问

问题2：
++这样可以避免Controller和M内部逻辑的耦合
-在何处定义一个Enum类是一个难于解决的问题

解决~
1：维持原判，将State作为实体的子节点更新访问
因为子节点可以访问父节点且可以对父节点的判断出截断甚至修改
2：介入Enum类，在Ref_Enum中定义AdvenTri的特有集合类

在Player数据库里加入Parry值。Player属性加入Parry选项

发现Player没有数据库，应该需要再建立，但是目前可以设置宏定义Parry值。
注意！由于Parry实现方式，这里不需要Parry值。。。也不需要ParryState

定义ExitTo和EnterFrom
使用HandleAction监听行为和控制。相当于一种统一接口。
ExitTo处理所有的后续操作，包括逻辑上的更新，动画上的更新，自身的销毁。
EnterFrom处理进入新状态的操作，包括状态的新设置。