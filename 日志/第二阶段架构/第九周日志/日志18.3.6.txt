最难办的事来了，目前的HandleInput操作似乎和我HandleInput的体系不一样。。。修改？不修改？
如何实现不修改的方案？修改该如何修改？

再看书，还有一个问题是具体操作的实现
比较具有可行性的一种方案是：
1：update函数中判断时间的缩进（避免计时器的混淆）
2：对不同行为仅有调度作用并不是以直接操作其内部逻辑的形式出现。
如 访问player->useItem（） 但不定义 useItem（）的内部代码

父子类等级结构现在已经完成，加入了StateTag方便判断退出和来自何种状态以决定使用何种函数

考虑：
1：Enter和Exit操作应当各司其职不要越权，但是又难以判定其删除与被删除的关系，所以是否需要在player类中执行其转换操作？还是把它作为子节点来自行执行转换操作？
2：是否要创建一个Enum操作类，表示实际操作而非直接输入？

问题1：
++这样可以有效避免进出双操作的耦合
+这样可以增强可读性
--这样会使handleInput操作意义不明
-编写的逻辑难度较高
-会破坏state和Player应有的层级结构导致越权访问？
倒是不会导致越级访问

问题2：
++这样可以避免Controller和M内部逻辑的耦合
-在何处定义一个Enum类是一个难于解决的问题

解决~
1：维持原判，将State作为实体的子节点更新访问
因为子节点可以访问父节点且可以对父节点的判断出截断甚至修改
2：介入Enum类，在Ref_Enum中定义AdvenTri的特有集合类

在Player数据库里加入Parry值。Player属性加入Parry选项

发现Player没有数据库，应该需要再建立，但是目前可以设置宏定义Parry值。
注意！由于Parry实现方式，这里不需要Parry值。。。也不需要ParryState

定义ExitTo和EnterFrom
使用HandleAction监听行为和控制。相当于一种统一接口。
ExitTo处理所有的后续操作，包括逻辑上的更新，动画上的更新，自身的销毁。
EnterFrom处理进入新状态的操作，包括状态的新设置。

*****************
以上为5日日志
*****************

这里考虑一个HurtAction的解决方案，hurtAction不仅表示受到伤害，还应当表示出伤害的数值和种类便于后续计算，这里显然不能够完善的实现，如果单单传递一个ID的话。而且State也应该包含OnFire OnPosion OnFrozen等状态，所以
1：需要双状态State，一个表示自身状态，一个表示负面状态
2：实体本身还需要一个能够表示其收到伤害种类和数值的属性，在出现外部操作需要时直接进行设置，然后调用onHurt方法，默认不设置为无属性，和伤害一点。

定义了一批直接使用的函数，和间接访问方法。

isHurting parry skill 等计时器，理应放在Player里，所以应当修改当前设计？
改！

skill似乎没有cooldown设置参数，现在DB_Skill和SD_Skill中增添项

妈也，我已经把冷却和吟唱时间封装到Skill类里了！
这样会导致很多的重复，应当把技能写出来。写在主角类里，则技能类应当提供一个getCoolDownTime的方法查询冷却时间。

技能类的更新方法改写？不！不需要更新方法了，技能类现在只保存一个表示冷却时间的float

成功的把系统剥离出来了。现在需要实现冷却器。

关于技能：gathering应当是Ready状态，Active以后才计算冷却时间

Parry也需要一个CoolDown控制系统 可能还需要一个Parry类？控制Parry的Type或者冷却或者持续时间？
决定了！但留到明天再实现 #熊猫捂脸

考虑到如此设置，attack和parry都再skill中才对。
改用Map表示skill

以simpleAttack为例，实现成功，明天开始补全工作。