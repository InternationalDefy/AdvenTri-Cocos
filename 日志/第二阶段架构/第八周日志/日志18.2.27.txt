以下为设计之目的，取自23日日志

注意
1：事件响应是一个链的形式，单种事情的添加不足以实现完整的监控
2：dispatchparser类cbparser类均被addChild给了父类，dispatcher给了其所属的实体类，callback给了其layer类，则需要注意
a：内存管理，注意在响应一个事件并消除其时，要移除listener并 removefromparent
b：场景切换，要remove事件的listener
这ab尚未实现，后天准备做之

考虑其eventSystem的管理方案，
1：有的callback只需运行一次，运行一次之后应该移除它
2：有的callback需要运行多次，但有运行的时间间隔
3：有的callback需要运行多次，但有运行的逻辑间隔
4：各种callback之间有明显的先后触发关系
这些管理问题的解决也许需要一个派生类系统，以最简单的parser为基类，同时需要修改.csv文件

当前阶段需要实现以上规划的目标。

进一步学习了解Event的优先级和移除操作
4：Fixed优先级也许是我们需要考虑的
3：管理一个事件末尾对另一个事件的触发（设置监听器？派发事件？）
2：Dispatcher冷却？Listener响应冷却？
1：运行之后移除响应？Dispatcher移除？还是都移除？
a，b：_eventDispatcher->removeEventListener(listener)

考虑以下问题：
事件的监听响应是Node的派生类，思考下几乎所有的事件响应都要依赖于Node存在，某些事件响应器添加在Entity上，有些则添加在Layer和Scene上，因此，Listener的移除应该考虑为Node移除时的一种操作。而对于一个事件的结束，只要有事件就应当被响应， 冷却的处理应当给派发器。同理，一次事件之后移除应当在派发器处移除。

监听器的移除可以依赖父节点的移除而移除，同时更新方法也会停止，监听器也可以靠移除自身节点而移除。
响应器的移除不仅要移除自身节点，还要移除该listener

1：响应的移除要考虑这个信息是不是需要移除，信息和响应并不是一一对应的关系。
移除派发器直接RemoveNode即可，移除响应器不仅需要RemoveNode，还需要RemoveListner。
2：响应器和派发器都可能存在冷却的事情，对于一一对应的响应，斩断头部即可结束响应，但是正确地实现应当是头尾共取。
这里可能需要考虑到System的管理机制。
Tag也许是一种行之有效的手段？System可能需要一个Vector？Map？去管理这些事件
3：派发器响应器和System应当具有上下级相互持有的关系？
4：在DB中的设置可能需要多加Fixed优先级。

设计修改：
DB的修改：
Callbacker加入Fixed项，int，-1是使用Node优先级，0+是Fixed
两者加入CoolDown项，float，冷却时间
两者加入Limit项，int，次数限制
以上三者的Handle操作可以在基类M里实现。
（目前否决！）加入Tag项？Tag难以管理因为同一种类的时间不能Tag相同
Sys的修改：
持有两个Vector，包含所有注册的Listener和Callbacker，在Sys和模型元关联时设置id
在移除操作是修改id

目前，在Callbacker层面实现了冷却和限制，但是内存管理尚未实现。

先考虑Callbacker的内存管理，毕竟Listener和Callbacker是照猫画虎的关系。

刚才看错了，现在在Sys层面添加了Both dispatcher和callbacker的新添加方案。
似乎不需要在System层面就可以执行对Callbacker的Remove操作，而且可以很简洁，固然用system持有可以方便管理，但是问题：
Vector直接持有，除非Erase不会autorelease，明天再考虑。
23333不断电！Callbacker的管理现已实现，用EventSystem的Erase机制。

啊？到底需不需要vector？床上考虑吧。。。

节外生枝，完成了一个摄像头高度可调的操作。

*****************
以上为26日日志
*****************

继续使用Vector，方便管理。同时可以集中卸载。
实现Callbacker的管理机制。
并且添加了一个自毁函数。

下面照猫画虎地完成ListenerFunc类。

完全实现！

具体的添加方法如之前记录。应当需要一个拓展方法的文件？